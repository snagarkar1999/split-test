"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise.finally");

var _setTimeout2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/set-timeout"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));

var _tape = _interopRequireDefault(require("tape"));

var _sinon = _interopRequireDefault(require("sinon"));

var _node = _interopRequireDefault(require("../../../storage/SegmentCache/InMemory/node"));

var _Keys = _interopRequireDefault(require("../../../storage/Keys"));

var _settings = _interopRequireDefault(require("../../../utils/settings"));

var _SegmentUpdateWorker = _interopRequireDefault(require("../../SegmentUpdateWorker/SegmentUpdateWorker"));

function ProducerMock(segmentStorage) {
  var __segmentsUpdaterCalls = [];

  function __segmentsUpdater() {
    return new _promise.default(function (res, rej) {
      __segmentsUpdaterCalls.push({
        res: res,
        rej: rej
      });
    });
  }

  var __isSynchronizingSegments = false;

  function isSynchronizingSegments() {
    return __isSynchronizingSegments;
  }

  function synchronizeSegment() {
    __isSynchronizingSegments = true;
    return __segmentsUpdater().finally(function () {
      __isSynchronizingSegments = false;
    });
  }

  return {
    isSynchronizingSegments: _sinon.default.spy(isSynchronizingSegments),
    synchronizeSegment: _sinon.default.spy(synchronizeSegment),
    __resolveSegmentsUpdaterCall: function __resolveSegmentsUpdaterCall(index, changeNumbers) {
      var _context;

      (0, _forEach.default)(_context = (0, _keys.default)(changeNumbers)).call(_context, function (segmentName) {
        segmentStorage.setChangeNumber(segmentName, changeNumbers[segmentName]); // update changeNumber in storage
      });

      __segmentsUpdaterCalls[index].res(); // resolve previous call

    }
  };
}

(0, _tape.default)('SegmentUpdateWorker', function (t) {
  // setup
  var cache = new _node.default(new _Keys.default((0, _settings.default)()));
  cache.addToSegment('mocked_segment_1', ['a', 'b', 'c']);
  cache.addToSegment('mocked_segment_2', ['d']);
  cache.addToSegment('mocked_segment_3', ['e']);
  var producer = ProducerMock(cache);
  var segmentUpdateWorker = new _SegmentUpdateWorker.default(cache, producer);
  segmentUpdateWorker.backoff.baseMillis = 0; // retry immediately

  t.deepEqual(segmentUpdateWorker.maxChangeNumbers, {}, 'inits with not queued events');
  t.test('put', function (assert) {
    // assert calling `synchronizeSegment` if `isSynchronizingSegments` is false
    assert.equal(producer.isSynchronizingSegments(), false);
    segmentUpdateWorker.put(100, 'mocked_segment_1');
    assert.deepEqual(segmentUpdateWorker.maxChangeNumbers, {
      'mocked_segment_1': 100
    }, 'queues events (changeNumbers) if they are mayor than storage changeNumbers and maxChangeNumbers');
    assert.true(producer.synchronizeSegment.calledOnce, 'calls `synchronizeSegment` if `isSynchronizingSegments` is false');
    assert.true(producer.synchronizeSegment.calledOnceWithExactly(['mocked_segment_1']), 'calls `synchronizeSegment` with segmentName'); // assert queueing items if `isSynchronizingSegments` is true

    assert.equal(producer.isSynchronizingSegments(), true);
    segmentUpdateWorker.put(95, 'mocked_segment_1');
    segmentUpdateWorker.put(100, 'mocked_segment_2');
    segmentUpdateWorker.put(105, 'mocked_segment_1');
    segmentUpdateWorker.put(94, 'mocked_segment_1');
    segmentUpdateWorker.put(94, 'mocked_segment_3');
    assert.deepEqual(segmentUpdateWorker.maxChangeNumbers, {
      'mocked_segment_1': 105,
      'mocked_segment_2': 100,
      'mocked_segment_3': 94
    }, 'queues events');
    assert.true(producer.synchronizeSegment.calledOnce, 'doesn\'t call `synchronizeSegment` if `isSynchronizingSegments` is true'); // assert dequeueing and recalling to `synchronizeSegment`

    producer.__resolveSegmentsUpdaterCall(0, {
      'mocked_segment_1': 100
    }); // resolve first call to `synchronizeSegment`


    (0, _setTimeout2.default)(function () {
      assert.equal(cache.getChangeNumber('mocked_segment_1'), 100, '100');
      assert.true(producer.synchronizeSegment.calledTwice, 'recalls `synchronizeSegment` if `isSynchronizingSegments` is false and queue is not empty');
      assert.true(producer.synchronizeSegment.lastCall.calledWithExactly(['mocked_segment_1', 'mocked_segment_2', 'mocked_segment_3']), 'calls `synchronizeSegment` with segmentName');
      assert.equal(segmentUpdateWorker.backoff.attempts, 0, 'no retry scheduled if synchronization success (changeNumbers are the expected)'); // assert reschedule synchronization if some changeNumber is not updated as expected

      producer.__resolveSegmentsUpdaterCall(1, {
        'mocked_segment_1': 100,
        'mocked_segment_2': 100,
        'mocked_segment_3': 94
      });

      (0, _setTimeout2.default)(function () {
        assert.equal(producer.synchronizeSegment.callCount, 3, 'recalls `synchronizeSegment` if synchronization fail (one changeNumber is not the expected)');
        assert.true(producer.synchronizeSegment.lastCall.calledWithExactly(['mocked_segment_1']), 'calls `synchronizeSegment` with the segmentName that failed to fetch');
        assert.equal(segmentUpdateWorker.backoff.attempts, 1, 'retry scheduled since synchronization failed (one changeNumber is not the expected)'); // assert dequeueing remaining events

        producer.__resolveSegmentsUpdaterCall(1, {
          'mocked_segment_1': 105
        }); // resolve third call to `synchronizeSegment`


        (0, _setTimeout2.default)(function () {
          assert.equal(producer.synchronizeSegment.callCount, 3, 'doesn\'t call `synchronizeSegment` again');
          assert.deepEqual(segmentUpdateWorker.maxChangeNumbers, {
            'mocked_segment_1': 105,
            'mocked_segment_2': 100,
            'mocked_segment_3': 94
          }, 'maxChangeNumbers'); // assert restarting retries, when a newer event is queued

          segmentUpdateWorker.put(110, 'mocked_segment_1'); // queued

          assert.equal(segmentUpdateWorker.backoff.attempts, 0, 'backoff scheduler for retries is reset if a new event is queued');
          assert.end();
        });
      }, 10); // wait a little bit until `synchronizeSegment` is called in next event-loop cycle
    });
  });
});