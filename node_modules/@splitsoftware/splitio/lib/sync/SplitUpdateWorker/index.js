"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _bind = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/bind"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));

var _backoff = _interopRequireDefault(require("../../utils/backoff"));

/**
 * SplitUpdateWorker class
 */
var SplitUpdateWorker = /*#__PURE__*/function () {
  /**
   * @param {Object} splitStorage splits cache
   * @param {Object} splitProducer node producer or full browser producer
   * @param {Object} splitsEventEmitter
   */
  function SplitUpdateWorker(splitStorage, splitProducer, splitsEventEmitter) {
    var _context, _context2, _context3;

    (0, _classCallCheck2.default)(this, SplitUpdateWorker);
    this.splitStorage = splitStorage;
    this.splitProducer = splitProducer;
    this.maxChangeNumber = 0;
    this.splitsEventEmitter = splitsEventEmitter;
    this.put = (0, _bind.default)(_context = this.put).call(_context, this);
    this.killSplit = (0, _bind.default)(_context2 = this.killSplit).call(_context2, this);
    this.__handleSplitUpdateCall = (0, _bind.default)(_context3 = this.__handleSplitUpdateCall).call(_context3, this);
    this.backoff = new _backoff.default(this.__handleSplitUpdateCall);
  } // Private method
  // Preconditions: this.splitProducer.isSynchronizingSplits === false


  (0, _createClass2.default)(SplitUpdateWorker, [{
    key: "__handleSplitUpdateCall",
    value: function __handleSplitUpdateCall() {
      var _this = this;

      if (this.maxChangeNumber > this.splitStorage.getChangeNumber()) {
        this.handleNewEvent = false;
        this.splitProducer.synchronizeSplits().then(function () {
          if (_this.handleNewEvent) {
            _this.__handleSplitUpdateCall();
          } else {
            _this.backoff.scheduleCall();
          }
        });
      }
    }
    /**
     * Invoked by NotificationProcessor on SPLIT_UPDATE event
     *
     * @param {number} changeNumber change number of the SPLIT_UPDATE notification
     */

  }, {
    key: "put",
    value: function put(changeNumber) {
      var currentChangeNumber = this.splitStorage.getChangeNumber();
      if (changeNumber <= currentChangeNumber || changeNumber <= this.maxChangeNumber) return;
      this.maxChangeNumber = changeNumber;
      this.handleNewEvent = true;
      this.backoff.reset();
      if (this.splitProducer.isSynchronizingSplits()) return;

      this.__handleSplitUpdateCall();
    }
    /**
     * Invoked by NotificationProcessor on SPLIT_KILL event
     *
     * @param {number} changeNumber change number of the SPLIT_UPDATE notification
     * @param {string} splitName name of split to kill
     * @param {string} defaultTreatment default treatment value
     */

  }, {
    key: "killSplit",
    value: function killSplit(changeNumber, splitName, defaultTreatment) {
      var _this2 = this;

      // @TODO handle retry due to errors in storage, once we allow the definition of custom async storages
      this.splitStorage.killLocally(splitName, defaultTreatment, changeNumber).then(function (updated) {
        // trigger an SDK_UPDATE if Split was killed locally
        if (updated) _this2.splitsEventEmitter.emit(_this2.splitsEventEmitter.SDK_SPLITS_ARRIVED, true); // queues the SplitChanges fetch (only if changeNumber is newer)

        _this2.put(changeNumber);
      });
    }
  }]);
  return SplitUpdateWorker;
}();

exports.default = SplitUpdateWorker;