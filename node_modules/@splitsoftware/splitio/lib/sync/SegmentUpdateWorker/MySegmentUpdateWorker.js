"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _bind = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/bind"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));

var _backoff = _interopRequireDefault(require("../../utils/backoff"));

/**
 * MySegmentUpdateWorker class
 */
var MySegmentUpdateWorker = /*#__PURE__*/function () {
  /**
   *
   * @param {Object} mySegmentsStorage
   * @param {Object} mySegmentsProducer
   */
  function MySegmentUpdateWorker(mySegmentsStorage, mySegmentsProducer) {
    var _context, _context2;

    (0, _classCallCheck2.default)(this, MySegmentUpdateWorker);
    this.mySegmentsStorage = mySegmentsStorage;
    this.mySegmentsProducer = mySegmentsProducer;
    this.maxChangeNumber = 0; // keeps the maximum changeNumber among queued events

    this.segmentList = undefined; // keeps the segmentList (if included in payload) from the queued event with maximum changeNumber

    this.currentChangeNumber = -1; // @TODO: remove once `/mySegments` endpoint provides the changeNumber

    this.put = (0, _bind.default)(_context = this.put).call(_context, this);
    this.__handleMySegmentUpdateCall = (0, _bind.default)(_context2 = this.__handleMySegmentUpdateCall).call(_context2, this);
    this.backoff = new _backoff.default(this.__handleMySegmentUpdateCall);
  } // Private method
  // Preconditions: this.mySegmentsProducer.isSynchronizingMySegments === false
  // @TODO update this block similar to SplitUpdateWorker, once `/mySegments` endpoint provides the changeNumber


  (0, _createClass2.default)(MySegmentUpdateWorker, [{
    key: "__handleMySegmentUpdateCall",
    value: function __handleMySegmentUpdateCall() {
      var _this = this;

      if (this.maxChangeNumber > this.currentChangeNumber) {
        this.handleNewEvent = false;
        var currentMaxChangeNumber = this.maxChangeNumber;
        this.mySegmentsProducer.synchronizeMySegments(this.segmentList).then(function (result) {
          if (result !== false) // @TODO remove when revamping producers. Currently `MySegmentsUpdater` is resolved with a "false" value if the fetch fails.
            _this.currentChangeNumber = Math.max(_this.currentChangeNumber, currentMaxChangeNumber); // use `currentMaxChangeNumber`, in case that `this.maxChangeNumber` was updated during fetch.

          if (_this.handleNewEvent) {
            _this.__handleMySegmentUpdateCall();
          } else {
            _this.backoff.scheduleCall();
          }
        });
      }
    }
    /**
     * Invoked by NotificationProcessor on MY_SEGMENTS_UPDATE event
     *
     * @param {number} changeNumber change number of the MY_SEGMENTS_UPDATE notification
     * @param {string[] | undefined} segmentList might be undefined
     */

  }, {
    key: "put",
    value: function put(changeNumber, segmentList) {
      // @TODO uncomment next line once `/mySegments` endpoint provides the changeNumber
      // const currentChangeNumber = this.mySegmentsStorage.getChangeNumber();
      if (changeNumber <= this.currentChangeNumber || changeNumber <= this.maxChangeNumber) return;
      this.maxChangeNumber = changeNumber;
      this.handleNewEvent = true;
      this.backoff.reset();
      this.segmentList = segmentList;
      if (this.mySegmentsProducer.isSynchronizingMySegments()) return;

      this.__handleMySegmentUpdateCall();
    }
  }]);
  return MySegmentUpdateWorker;
}();

exports.default = MySegmentUpdateWorker;