"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _some = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/some"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/typeof"));

var _lang = require("../../../utils/lang");

var _parseCondition = _interopRequireDefault(require("./parseCondition"));

var previousMock = {
  'emptyMock': 1
};

function hasTreatmentChanged(prev, curr) {
  if ((0, _typeof2.default)(prev) !== (0, _typeof2.default)(curr)) return true;

  if (typeof prev === 'string') {
    // strings treatments, just compare
    return prev !== curr;
  } else {
    // has treatment and config, compare both
    return prev.treatment !== curr.treatment || prev.config !== curr.config;
  }
}

function mockUpdated(currentData) {
  var names = (0, _keys.default)(currentData); // Different amount of items

  if (names.length !== (0, _keys.default)(previousMock).length) {
    previousMock = currentData;
    return true;
  }

  return (0, _some.default)(names).call(names, function (name) {
    var newSplit = !previousMock[name];
    var newTreatment = hasTreatmentChanged(previousMock[name], currentData[name]);
    var changed = newSplit || newTreatment;
    if (changed) previousMock = currentData;
    return changed;
  });
}

function getConfigurationFromSettings(settings) {
  var mockSettings = settings.features || {};
  if (!mockUpdated(mockSettings)) return false;
  var splitObjects = {};
  (0, _lang.forOwn)(mockSettings, function (data, splitName) {
    var treatment = data;
    var config = null;

    if ((0, _lang.isObject)(data)) {
      treatment = data.treatment;
      config = data.config || config;
    }

    var configurations = {};
    if (config !== null) configurations[treatment] = config;
    splitObjects[splitName] = {
      conditions: [(0, _parseCondition.default)({
        treatment: treatment
      })],
      configurations: configurations
    };
  });
  return splitObjects;
}

var _default = getConfigurationFromSettings;
exports.default = _default;