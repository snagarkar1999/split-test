"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

require("core-js/modules/es.array.join");

require("core-js/modules/es.regexp.constructor");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.split");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/define-property"));

var _defineProperties = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/define-properties"));

var _getOwnPropertyDescriptors = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _getOwnPropertyDescriptor = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));

var _getOwnPropertySymbols = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));

var _now = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/date/now"));

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));

var _setTimeout2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/set-timeout"));

var _defineProperty3 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/defineProperty"));

var _bind = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/bind"));

var _path = _interopRequireDefault(require("path"));

var _tapeCatch = _interopRequireDefault(require("tape-catch"));

var _sinon = _interopRequireDefault(require("sinon"));

var _fetchMock = _interopRequireDefault(require("../utils/fetchMock"));

var _ = require("../../");

var _settings = _interopRequireDefault(require("../../utils/settings"));

function ownKeys(object, enumerableOnly) { var keys = (0, _keys.default)(object); if (_getOwnPropertySymbols.default) { var symbols = (0, _getOwnPropertySymbols.default)(object); if (enumerableOnly) symbols = (0, _filter.default)(symbols).call(symbols, function (sym) { return (0, _getOwnPropertyDescriptor.default)(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context6; (0, _forEach.default)(_context6 = ownKeys(Object(source), true)).call(_context6, function (key) { (0, _defineProperty3.default)(target, key, source[key]); }); } else if (_getOwnPropertyDescriptors.default) { (0, _defineProperties.default)(target, (0, _getOwnPropertyDescriptors.default)(source)); } else { var _context7; (0, _forEach.default)(_context7 = ownKeys(Object(source))).call(_context7, function (key) { (0, _defineProperty2.default)(target, key, (0, _getOwnPropertyDescriptor.default)(source, key)); }); } } return target; }

var settings = (0, _settings.default)({
  core: {
    key: 'facundo@split.io'
  }
});

var spySplitChanges = _sinon.default.spy();

var spySegmentChanges = _sinon.default.spy();

var spyMySegments = _sinon.default.spy();

var spyEventsBulk = _sinon.default.spy();

var spyTestImpressionsBulk = _sinon.default.spy();

var spyMetricsTimes = _sinon.default.spy();

var spyMetricsCounters = _sinon.default.spy();

var spyAny = _sinon.default.spy(); // helper function that should call the spy function and return a 200 to keep
// going the fetch request flow


var replySpy = function replySpy(spy) {
  spy();
  return 200;
};

var configMocks = function configMocks() {
  _fetchMock.default.mock(new RegExp("".concat(settings.url('/splitChanges/'), ".*")), function () {
    return replySpy(spySplitChanges);
  });

  _fetchMock.default.mock(new RegExp("".concat(settings.url('/segmentChanges/'), ".*")), function () {
    return replySpy(spySegmentChanges);
  });

  _fetchMock.default.mock(new RegExp("".concat(settings.url('/mySegments/'), ".*")), function () {
    return replySpy(spyMySegments);
  });

  _fetchMock.default.mock(settings.url('/events/bulk'), function () {
    return replySpy(spyEventsBulk);
  });

  _fetchMock.default.mock(settings.url('/testImpressions/bulk'), function () {
    return replySpy(spyTestImpressionsBulk);
  });

  _fetchMock.default.mock(settings.url('/metrics/times'), function () {
    return replySpy(spyMetricsTimes);
  });

  _fetchMock.default.mock(settings.url('/metrics/counters'), function () {
    return replySpy(spyMetricsCounters);
  });

  _fetchMock.default.mock('*', function () {
    return replySpy(spyAny);
  });
};

var settingsGenerator = function settingsGenerator(mockFileName) {
  return {
    core: {
      authorizationKey: 'localhost'
    },
    scheduler: {
      impressionsRefreshRate: 0.01,
      eventsPushRate: 0.01,
      metricsRefreshRate: 0.01,
      offlineRefreshRate: 0.3
    },
    startup: {
      eventsFirstPushWindow: 0,
      readyTimeout: 3,
      retriesOnFailureBeforeReady: 0
    },
    features: _path.default.join(__dirname, mockFileName)
  };
};

(0, _tapeCatch.default)('NodeJS Offline Mode', function (t) {
  t.test('Old format evaluations - .split', DotSplitTests);
  t.test('New format evaluations - .yaml extension', (0, _bind.default)(DotYAMLTests).call(DotYAMLTests, null, 'split', 'yaml'));
  t.test('New format evaluations - .yml extension', (0, _bind.default)(DotYAMLTests).call(DotYAMLTests, null, 'split2', 'yml'));
  t.test('Old format manager - .split extension', ManagerDotSplitTests);
  t.test('New format manager - .yaml extension', (0, _bind.default)(ManagerDotYamlTests).call(ManagerDotYamlTests, null, 'split.yaml'));
  t.test('New format manager - .yml extension', (0, _bind.default)(ManagerDotYamlTests).call(ManagerDotYamlTests, null, 'split2.yml'));
  t.test('Trying to specify an invalid extension it will timeout', function (assert) {
    var config = settingsGenerator('.forbidden');

    _sinon.default.spy(console, 'log');

    var factory = (0, _.SplitFactory)(_objectSpread({}, config, {
      debug: 'ERROR'
    })); // enable error level logs to check the message.

    var client = factory.client();
    client.on(client.Event.SDK_READY, function () {
      assert.fail('If tried to load a file with invalid extension, we should not get SDK_READY.');
      client.destroy();
      assert.end();
    });
    client.on(client.Event.SDK_READY_TIMED_OUT, function () {
      assert.pass('If tried to load a file with invalid extension, we should emit SDK_READY_TIMED_OUT.');
      assert.ok(console.log.calledWithMatch("[ERROR] splitio-producer:offline => There was an issue loading the mock Splits data, no changes will be applied to the current cache. Invalid extension specified for Splits mock file. Accepted extensions are \".yml\" and \".yaml\". Your specified file is ".concat(config.features)));
      console.log.restore();
      client.destroy();
      assert.end();
    });
  });
});

function networkAssertions(client, assert) {
  return client.destroy().then(function () {
    // We test the breakdown instead of just the misc because it's faster to spot where the issue is
    assert.notOk(spySplitChanges.called, 'On offline mode we should not call the splitChanges endpoint.');
    assert.notOk(spySegmentChanges.called, 'On offline mode we should not call the segmentChanges endpoint.');
    assert.notOk(spyMySegments.called, 'On offline mode we should not call the mySegments endpoint.');
    assert.notOk(spyEventsBulk.called, 'On offline mode we should not call the events endpoint.');
    assert.notOk(spyTestImpressionsBulk.called, 'On offline mode we should not call the impressions endpoint.');
    assert.notOk(spyMetricsTimes.called, 'On offline mode we should not call the metric times endpoint.');
    assert.notOk(spyMetricsCounters.called, 'On offline mode we should not call the metric counters endpoint.');
    assert.notOk(spyAny.called, 'On offline mode we should NOT call to ANY endpoint, we are completely isolated from BE.');
  });
}

function DotSplitTests(assert) {
  configMocks();
  var config = settingsGenerator('.split');
  var factory = (0, _.SplitFactory)(config);
  var client = factory.client(); // Tracking some events to test they are not flushed.

  client.track('a_key', 'a_tt', 'an_ev_id');
  client.track('another_key', 'another_tt', 'another_ev_id', 25);
  client.on(client.Event.SDK_READY, function () {
    assert.equal(client.getTreatment('qa-user', 'testing_split'), 'on');
    assert.equal(client.getTreatment('qa-user', 'testing_split_2'), 'control');
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'testing_split'), {
      treatment: 'on',
      config: null
    });
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'testing_split_2'), {
      treatment: 'control',
      config: null
    });
    assert.deepEqual(client.getTreatments('qa-user', ['testing_split', 'testing_split2', 'testing_split3', 'testing_not_exist']), {
      testing_split: 'on',
      testing_split2: 'off',
      testing_split3: 'custom_treatment',
      testing_not_exist: 'control'
    });
    assert.deepEqual(client.getTreatmentsWithConfig('qa-user', ['testing_split', 'testing_split2', 'testing_split3', 'testing_not_exist']), {
      testing_split: {
        treatment: 'on',
        config: null
      },
      testing_split2: {
        treatment: 'off',
        config: null
      },
      testing_split3: {
        treatment: 'custom_treatment',
        config: null
      },
      testing_not_exist: {
        treatment: 'control',
        config: null
      }
    });
    (0, _setTimeout2.default)(function () {
      factory.settings.features = _path.default.join(__dirname, '.split');
    }, 290);
    (0, _setTimeout2.default)(function () {
      factory.settings.features = _path.default.join(__dirname, '.split');
    }, 590);
    (0, _setTimeout2.default)(function () {
      factory.settings.features = _path.default.join(__dirname, '.split');
    }, 890);
    (0, _setTimeout2.default)(function () {
      factory.settings.features = _path.default.join(__dirname, 'update.split');
    }, 1000);
    client.once(client.Event.SDK_UPDATE, function () {
      assert.equal(client.getTreatment('qa-user', 'testing_split4'), 'updated_treatment');
      networkAssertions(client, assert).then(function () {
        client.destroy().then(assert.end);
      });
    });
  });
}

function DotYAMLTests(mockFileName, mockFileExt, assert) {
  var _context;

  configMocks();
  var config = settingsGenerator((0, _concat.default)(_context = "".concat(mockFileName, ".")).call(_context, mockFileExt));
  var factory = (0, _.SplitFactory)(config);
  var client = factory.client(); // Tracking some events to test they are not flushed.

  assert.true(client.track('a_key', 'a_tt', 'an_ev_id'));
  assert.true(client.track('another_key', 'another_tt', 'another_ev_id', 25));
  assert.false(client.track('wasa', {}, [], 'invalid_stuff'));
  client.on(client.Event.SDK_READY, function () {
    assert.equal(client.getTreatment('qa-user', 'testing_split_on'), 'on');
    assert.equal(client.getTreatment('qa-user', 'testing_split_only_wl'), 'control');
    assert.equal(client.getTreatment('key_for_wl', 'testing_split_only_wl'), 'whitelisted');
    assert.equal(client.getTreatment('qa-user', 'testing_split_with_wl'), 'not_in_whitelist');
    assert.equal(client.getTreatment('key_for_wl', 'testing_split_with_wl'), 'one_key_wl');
    assert.equal(client.getTreatment('key_for_wl_1', 'testing_split_with_wl'), 'multi_key_wl');
    assert.equal(client.getTreatment('key_for_wl_2', 'testing_split_with_wl'), 'multi_key_wl');
    assert.equal(client.getTreatment('qa-user', 'testing_split_off_with_config'), 'off');
    assert.equal(client.getTreatment('qa-user', 'not_existent'), 'control');
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'testing_split_on'), {
      treatment: 'on',
      config: null
    });
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'testing_split_only_wl'), {
      treatment: 'control',
      config: null
    });
    assert.deepEqual(client.getTreatmentWithConfig('key_for_wl', 'testing_split_only_wl'), {
      treatment: 'whitelisted',
      config: null
    });
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'testing_split_with_wl'), {
      treatment: 'not_in_whitelist',
      config: '{"color": "green"}'
    });
    assert.deepEqual(client.getTreatmentWithConfig('key_for_wl', 'testing_split_with_wl'), {
      treatment: 'one_key_wl',
      config: null
    });
    assert.deepEqual(client.getTreatmentWithConfig('key_for_wl_1', 'testing_split_with_wl'), {
      treatment: 'multi_key_wl',
      config: '{"color": "brown"}'
    });
    assert.deepEqual(client.getTreatmentWithConfig('key_for_wl_2', 'testing_split_with_wl'), {
      treatment: 'multi_key_wl',
      config: '{"color": "brown"}'
    });
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'testing_split_off_with_config'), {
      treatment: 'off',
      config: '{"color": "green"}'
    });
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'not_existent'), {
      treatment: 'control',
      config: null
    });
    assert.deepEqual(client.getTreatments('qa-user', ['testing_split_on', 'testing_split_only_wl', 'testing_split_with_wl', 'testing_split_off_with_config', 'testing_not_exist']), {
      testing_split_on: 'on',
      testing_split_only_wl: 'control',
      testing_split_with_wl: 'not_in_whitelist',
      testing_split_off_with_config: 'off',
      testing_not_exist: 'control'
    });
    assert.deepEqual(client.getTreatmentsWithConfig('key_for_wl', ['testing_split_on', 'testing_split_only_wl', 'testing_split_with_wl', 'testing_split_off_with_config', 'testing_not_exist']), {
      testing_split_on: {
        treatment: 'on',
        config: null
      },
      testing_split_only_wl: {
        treatment: 'whitelisted',
        config: null
      },
      testing_split_with_wl: {
        treatment: 'one_key_wl',
        config: null
      },
      testing_split_off_with_config: {
        treatment: 'off',
        config: '{"color": "green"}'
      },
      testing_not_exist: {
        treatment: 'control',
        config: null
      }
    });
    var readyTimestamp = (0, _now.default)();
    (0, _setTimeout2.default)(function () {
      var _context2;

      factory.settings.features = _path.default.join(__dirname, (0, _concat.default)(_context2 = "".concat(mockFileName, ".")).call(_context2, mockFileExt));
    }, 290);
    (0, _setTimeout2.default)(function () {
      var _context3;

      factory.settings.features = _path.default.join(__dirname, (0, _concat.default)(_context3 = "".concat(mockFileName, ".")).call(_context3, mockFileExt));
    }, 590);
    (0, _setTimeout2.default)(function () {
      var _context4;

      factory.settings.features = _path.default.join(__dirname, (0, _concat.default)(_context4 = "".concat(mockFileName, ".")).call(_context4, mockFileExt));
    }, 890);
    (0, _setTimeout2.default)(function () {
      var _context5;

      factory.settings.features = _path.default.join(__dirname, (0, _concat.default)(_context5 = "update.".concat(mockFileName, ".")).call(_context5, mockFileExt));
    }, 1000);
    client.once(client.Event.SDK_UPDATE, function () {
      assert.equal(client.getTreatment('qa-user', 'testing_split_update'), 'updated_treatment', 'the update should be properly processed');
      assert.true((0, _now.default)() - readyTimestamp > 1000);
      networkAssertions(client, assert).then(function () {
        client.destroy().then(assert.end);
      });
    });
  });
}

function ManagerDotSplitTests(assert) {
  configMocks();
  var config = settingsGenerator('.split');
  var factory = (0, _.SplitFactory)(config);
  var client = factory.client();
  var manager = factory.manager();
  manager.on(manager.Event.SDK_READY, function () {
    assert.deepEqual(manager.names(), ['testing_split', 'testing_split2', 'testing_split3']);
    var expectedView1 = {
      name: 'testing_split',
      changeNumber: 0,
      killed: false,
      trafficType: null,
      treatments: ['on'],
      configs: {}
    };
    var expectedView2 = {
      name: 'testing_split2',
      changeNumber: 0,
      killed: false,
      trafficType: null,
      treatments: ['off'],
      configs: {}
    };
    var expectedView3 = {
      name: 'testing_split3',
      changeNumber: 0,
      killed: false,
      trafficType: null,
      treatments: ['custom_treatment'],
      configs: {}
    };
    assert.deepEqual(manager.split('testing_split'), expectedView1);
    assert.deepEqual(manager.split('testing_split2'), expectedView2);
    assert.deepEqual(manager.split('testing_split3'), expectedView3);
    assert.equal(manager.split('split_not_existent'), null);
    assert.deepEqual(manager.splits(), [expectedView1, expectedView2, expectedView3]);
    networkAssertions(client, assert).then(function () {
      client.destroy().then(assert.end);
    });
  });
}

function ManagerDotYamlTests(mockFileName, assert) {
  configMocks();
  var config = settingsGenerator(mockFileName);
  var factory = (0, _.SplitFactory)(config);
  var client = factory.client();
  var manager = factory.manager();
  manager.on(manager.Event.SDK_READY, function () {
    assert.deepEqual(manager.names(), ['testing_split_on', 'testing_split_only_wl', 'testing_split_with_wl', 'testing_split_off_with_config']);
    var expectedView1 = {
      name: 'testing_split_on',
      changeNumber: 0,
      killed: false,
      trafficType: 'localhost',
      treatments: ['on'],
      configs: {}
    };
    var expectedView2 = {
      name: 'testing_split_only_wl',
      changeNumber: 0,
      killed: false,
      trafficType: 'localhost',
      treatments: ['whitelisted'],
      configs: {}
    };
    var expectedView3 = {
      name: 'testing_split_with_wl',
      changeNumber: 0,
      killed: false,
      trafficType: 'localhost',
      treatments: ['not_in_whitelist', 'one_key_wl', 'multi_key_wl'],
      configs: {
        not_in_whitelist: '{"color": "green"}',
        multi_key_wl: '{"color": "brown"}'
      }
    };
    var expectedView4 = {
      name: 'testing_split_off_with_config',
      changeNumber: 0,
      killed: false,
      trafficType: 'localhost',
      treatments: ['off'],
      configs: {
        off: '{"color": "green"}'
      }
    };
    assert.deepEqual(manager.split('testing_split_on'), expectedView1);
    assert.deepEqual(manager.split('testing_split_only_wl'), expectedView2);
    assert.deepEqual(manager.split('testing_split_with_wl'), expectedView3);
    assert.deepEqual(manager.split('testing_split_off_with_config'), expectedView4);
    assert.equal(manager.split('not_existent'), null);
    assert.deepEqual(manager.splits(), [expectedView1, expectedView2, expectedView3, expectedView4]);
    networkAssertions(client, assert).then(function () {
      client.destroy().then(assert.end);
    });
  });
}