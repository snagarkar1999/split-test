"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.constructor");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.iterator");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/define-property"));

var _defineProperties = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/define-properties"));

var _getOwnPropertyDescriptors = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _getOwnPropertyDescriptor = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));

var _getOwnPropertySymbols = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));

var _defineProperty3 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/defineProperty"));

var _setTimeout2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/set-timeout"));

var _now = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/date/now"));

var _tapeCatch = _interopRequireDefault(require("tape-catch"));

var _sinon = _interopRequireDefault(require("sinon"));

var _fetchMock = _interopRequireDefault(require("../utils/fetchMock"));

var _ = require("../../");

var _settings = _interopRequireDefault(require("../../utils/settings"));

function ownKeys(object, enumerableOnly) { var keys = (0, _keys.default)(object); if (_getOwnPropertySymbols.default) { var symbols = (0, _getOwnPropertySymbols.default)(object); if (enumerableOnly) symbols = (0, _filter.default)(symbols).call(symbols, function (sym) { return (0, _getOwnPropertyDescriptor.default)(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context; (0, _forEach.default)(_context = ownKeys(Object(source), true)).call(_context, function (key) { (0, _defineProperty3.default)(target, key, source[key]); }); } else if (_getOwnPropertyDescriptors.default) { (0, _defineProperties.default)(target, (0, _getOwnPropertyDescriptors.default)(source)); } else { var _context2; (0, _forEach.default)(_context2 = ownKeys(Object(source))).call(_context2, function (key) { (0, _defineProperty2.default)(target, key, (0, _getOwnPropertyDescriptor.default)(source, key)); }); } } return target; }

var settings = (0, _settings.default)({
  core: {
    key: 'facundo@split.io'
  }
});

var spySplitChanges = _sinon.default.spy();

var spySegmentChanges = _sinon.default.spy();

var spyMySegments = _sinon.default.spy();

var spyEventsBulk = _sinon.default.spy();

var spyTestImpressionsBulk = _sinon.default.spy();

var spyMetricsTimes = _sinon.default.spy();

var spyMetricsCounters = _sinon.default.spy();

var spyAny = _sinon.default.spy(); // helper function that should call the spy function and return a 200 to keep
// going the fetch request flow


var replySpy = function replySpy(spy) {
  spy();
  return 200;
};

var configMocks = function configMocks() {
  _fetchMock.default.mock(new RegExp("".concat(settings.url('/splitChanges/'), ".*")), function () {
    return replySpy(spySplitChanges);
  });

  _fetchMock.default.mock(new RegExp("".concat(settings.url('/segmentChanges/'), ".*")), function () {
    return replySpy(spySegmentChanges);
  });

  _fetchMock.default.mock(new RegExp("".concat(settings.url('/mySegments/'), ".*")), function () {
    return replySpy(spyMySegments);
  });

  _fetchMock.default.mock(settings.url('/events/bulk'), function () {
    return replySpy(spyEventsBulk);
  });

  _fetchMock.default.mock(settings.url('/testImpressions/bulk'), function () {
    return replySpy(spyTestImpressionsBulk);
  });

  _fetchMock.default.mock(settings.url('/metrics/times'), function () {
    return replySpy(spyMetricsTimes);
  });

  _fetchMock.default.mock(settings.url('/metrics/counters'), function () {
    return replySpy(spyMetricsCounters);
  });

  _fetchMock.default.mock('*', function () {
    return replySpy(spyAny);
  });
};

(0, _tapeCatch.default)('Browser offline mode', function (assert) {
  configMocks();
  var originalFeaturesMap = {
    testing_split: 'on',
    testing_split_with_config: {
      treatment: 'off',
      config: '{ "color": "blue" }'
    }
  };
  var config = {
    core: {
      authorizationKey: 'localhost'
    },
    scheduler: {
      impressionsRefreshRate: 0.01,
      eventsPushRate: 0.01,
      metricsRefreshRate: 0.01,
      offlineRefreshRate: 0.19
    },
    startup: {
      eventsFirstPushWindow: 0
    },
    features: originalFeaturesMap
  };
  var factory = (0, _.SplitFactory)(config);
  var manager = factory.manager();
  var client = factory.client();
  var sharedClient = factory.client('nicolas.zelaya@split.io'); // Tracking some events to test they are not flushed.

  assert.true(client.track('a_tt', 'an_ev_id'));
  assert.true(client.track('another_tt', 'another_ev_id', 25));
  assert.false(client.track({}, [], 'invalid_stuff'));
  assert.true(sharedClient.track('a_tt', 'another_ev_id', 10));
  assert.equal(client.getTreatment('testing_split'), 'control');
  assert.equal(manager.splits().length, 0);
  client.once(client.Event.SDK_READY, function () {
    var readyTimestamp = (0, _now.default)(); // Check the information through the client original instance

    assert.equal(client.getTreatment('testing_split'), 'on');
    assert.equal(client.getTreatment('testing_split_2'), 'control');
    assert.equal(client.getTreatment('testing_split_with_config'), 'off');
    assert.deepEqual(client.getTreatments(['testing_split', 'testing_split_2', 'testing_split_with_config']), {
      testing_split: 'on',
      testing_split_2: 'control',
      testing_split_with_config: 'off'
    }); // with config

    assert.deepEqual(client.getTreatmentWithConfig('testing_split'), {
      treatment: 'on',
      config: null
    });
    assert.deepEqual(client.getTreatmentWithConfig('testing_split_with_config'), {
      treatment: 'off',
      config: '{ "color": "blue" }'
    });
    assert.deepEqual(client.getTreatmentsWithConfig(['testing_split', 'testing_split_2', 'testing_split_with_config']), {
      testing_split: {
        treatment: 'on',
        config: null
      },
      testing_split_2: {
        treatment: 'control',
        config: null
      },
      testing_split_with_config: {
        treatment: 'off',
        config: '{ "color": "blue" }'
      }
    }); // Manager tests

    var expectedSplitView1 = {
      name: 'testing_split',
      trafficType: null,
      killed: false,
      changeNumber: 0,
      treatments: ['on'],
      configs: {}
    };
    var expectedSplitView2 = {
      name: 'testing_split_with_config',
      trafficType: null,
      killed: false,
      changeNumber: 0,
      treatments: ['off'],
      configs: {
        off: '{ "color": "blue" }'
      }
    };
    assert.deepEqual(manager.names(), ['testing_split', 'testing_split_with_config']);
    assert.deepEqual(manager.split('testing_split'), expectedSplitView1);
    assert.deepEqual(manager.split('testing_split_with_config'), expectedSplitView2);
    assert.deepEqual(manager.split('not_existent'), null);
    assert.deepEqual(manager.splits(), [expectedSplitView1, expectedSplitView2]); // And then through the shared instance.

    assert.equal(sharedClient.getTreatment('testing_split'), 'on');
    assert.equal(sharedClient.getTreatment('testing_split_2'), 'control');
    assert.deepEqual(sharedClient.getTreatments(['testing_split', 'testing_split_2', 'testing_split_with_config']), {
      testing_split: 'on',
      testing_split_2: 'control',
      testing_split_with_config: 'off'
    }); // with config

    assert.deepEqual(sharedClient.getTreatmentWithConfig('testing_split'), {
      treatment: 'on',
      config: null
    });
    assert.deepEqual(sharedClient.getTreatmentsWithConfig(['testing_split', 'testing_split_2', 'testing_split_with_config']), {
      testing_split: {
        treatment: 'on',
        config: null
      },
      testing_split_2: {
        treatment: 'control',
        config: null
      },
      testing_split_with_config: {
        treatment: 'off',
        config: '{ "color": "blue" }'
      }
    });
    (0, _setTimeout2.default)(function () {
      // Update the features.
      factory.settings.features = {
        testing_split: 'on',
        testing_split_2: 'off',
        testing_split_3: 'custom_treatment',
        testing_split_with_config: {
          treatment: 'nope',
          config: null
        }
      };
    }, 1000);
    (0, _setTimeout2.default)(function () {
      factory.settings.features = originalFeaturesMap;
    }, 200);
    (0, _setTimeout2.default)(function () {
      factory.settings.features = {
        testing_split: 'on',
        testing_split_with_config: {
          treatment: 'off',
          config: '{ "color": "blue" }'
        }
      };
    }, 400);
    (0, _setTimeout2.default)(function () {
      factory.settings.features = originalFeaturesMap;
    }, 600);
    (0, _setTimeout2.default)(function () {
      factory.settings.features = {
        testing_split: 'on',
        testing_split_with_config: {
          treatment: 'off',
          config: '{ "color": "blue" }'
        }
      };
    }, 750); // once updated, test again.

    client.once(client.Event.SDK_UPDATE, function () {
      assert.true((0, _now.default)() - readyTimestamp > 1000, 'Should only emit SDK_UPDATE after a real update.');
      assert.equal(client.getTreatment('testing_split_2'), 'off');
      assert.equal(client.getTreatment('testing_split_3'), 'custom_treatment');
      assert.deepEqual(client.getTreatmentWithConfig('testing_split_3'), {
        treatment: 'custom_treatment',
        config: null
      });
      assert.deepEqual(client.getTreatmentWithConfig('testing_split_with_config'), {
        treatment: 'nope',
        config: null
      });
      assert.deepEqual(client.getTreatments(['testing_split', 'testing_split_2', 'testing_split_3', 'testing_split_with_config', 'testing_not_exist']), {
        testing_split: 'on',
        testing_split_2: 'off',
        testing_split_3: 'custom_treatment',
        testing_split_with_config: 'nope',
        testing_not_exist: 'control'
      });
      assert.deepEqual(client.getTreatmentsWithConfig(['testing_split_2', 'testing_split_3', 'testing_split_with_config']), {
        testing_split_2: {
          treatment: 'off',
          config: null
        },
        testing_split_3: {
          treatment: 'custom_treatment',
          config: null
        },
        testing_split_with_config: {
          treatment: 'nope',
          config: null
        }
      }); // Manager tests

      var expectedSplitView3 = {
        name: 'testing_split_with_config',
        trafficType: null,
        killed: false,
        changeNumber: 0,
        treatments: ['nope'],
        configs: {}
      };
      assert.deepEqual(manager.names(), ['testing_split', 'testing_split_2', 'testing_split_3', 'testing_split_with_config']);
      assert.deepEqual(manager.split('testing_split'), expectedSplitView1);
      assert.deepEqual(manager.split('not_existent'), null);
      assert.deepEqual(manager.split('testing_split_with_config'), expectedSplitView3);
      assert.deepEqual(manager.splits(), [expectedSplitView1, _objectSpread({}, expectedSplitView3, {
        name: 'testing_split_2',
        treatments: ['off']
      }), _objectSpread({}, expectedSplitView3, {
        name: 'testing_split_3',
        treatments: ['custom_treatment']
      }), expectedSplitView3]); // Test shared client for the same data

      assert.equal(sharedClient.getTreatment('testing_split_2'), 'off');
      assert.equal(sharedClient.getTreatment('testing_split_3'), 'custom_treatment');
      assert.deepEqual(sharedClient.getTreatmentWithConfig('testing_split_3'), {
        treatment: 'custom_treatment',
        config: null
      });
      assert.deepEqual(sharedClient.getTreatmentWithConfig('testing_split_with_config'), {
        treatment: 'nope',
        config: null
      });
      assert.deepEqual(sharedClient.getTreatments(['testing_split', 'testing_split_2', 'testing_split_3', 'testing_not_exist']), {
        testing_split: 'on',
        testing_split_2: 'off',
        testing_split_3: 'custom_treatment',
        testing_not_exist: 'control'
      });
      assert.deepEqual(sharedClient.getTreatmentsWithConfig(['testing_split_3', 'testing_not_exist']), {
        testing_split_3: {
          treatment: 'custom_treatment',
          config: null
        },
        testing_not_exist: {
          treatment: 'control',
          config: null
        }
      });
      var sharedClientDestroyPromise = sharedClient.destroy();
      var mainClientDestroyPromise = client.destroy(); // When both promises have been resolved, we check for network activity

      _promise.default.all([sharedClientDestroyPromise, mainClientDestroyPromise]).then(function () {
        // We test the breakdown instead of just the misc because it's faster to spot where the issue is
        assert.notOk(spySplitChanges.called, 'On offline mode we should not call the splitChanges endpoint.');
        assert.notOk(spySegmentChanges.called, 'On offline mode we should not call the segmentChanges endpoint.');
        assert.notOk(spyMySegments.called, 'On offline mode we should not call the mySegments endpoint.');
        assert.notOk(spyEventsBulk.called, 'On offline mode we should not call the events endpoint.');
        assert.notOk(spyTestImpressionsBulk.called, 'On offline mode we should not call the impressions endpoint.');
        assert.notOk(spyMetricsTimes.called, 'On offline mode we should not call the metric times endpoint.');
        assert.notOk(spyMetricsCounters.called, 'On offline mode we should not call the metric counters endpoint.');
        assert.notOk(spyAny.called, 'On offline mode we should NOT call to ANY endpoint, we are completely isolated from BE.');
        assert.end();
      });
    }, 3500);
  });
});