"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty2 = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

_Object$defineProperty2(exports, "__esModule", {
  value: true
});

exports.default = _default;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/define-property"));

var _defineProperties = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/define-properties"));

var _getOwnPropertyDescriptors = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _getOwnPropertyDescriptor = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));

var _getOwnPropertySymbols = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));

var _now = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/date/now"));

var _setTimeout2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/set-timeout"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));

var _defineProperty3 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/defineProperty"));

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/json/stringify"));

var _ = require("../../");

var _splitchangesSince = _interopRequireDefault(require("../mocks/splitchanges.since.-1.json"));

var _splitchangesSince2 = _interopRequireDefault(require("../mocks/splitchanges.since.1457552620999.json"));

var _mysegmentsNicolasSplitIo = _interopRequireDefault(require("../mocks/mysegments.nicolas@split.io.json"));

function ownKeys(object, enumerableOnly) { var keys = (0, _keys.default)(object); if (_getOwnPropertySymbols.default) { var symbols = (0, _getOwnPropertySymbols.default)(object); if (enumerableOnly) symbols = (0, _filter.default)(symbols).call(symbols, function (sym) { return (0, _getOwnPropertyDescriptor.default)(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context; (0, _forEach.default)(_context = ownKeys(Object(source), true)).call(_context, function (key) { (0, _defineProperty3.default)(target, key, source[key]); }); } else if (_getOwnPropertyDescriptors.default) { (0, _defineProperties.default)(target, (0, _getOwnPropertyDescriptors.default)(source)); } else { var _context2; (0, _forEach.default)(_context2 = ownKeys(Object(source))).call(_context2, function (key) { (0, _defineProperty2.default)(target, key, (0, _getOwnPropertyDescriptor.default)(source, key)); }); } } return target; }

var alwaysOnSplitInverted = (0, _stringify.default)({
  'environment': null,
  'trafficTypeId': null,
  'trafficTypeName': null,
  'name': 'always_on',
  'seed': -790401604,
  'status': 'ACTIVE',
  'killed': false,
  'defaultTreatment': 'off',
  'conditions': [{
    'matcherGroup': {
      'combiner': 'AND',
      'matchers': [{
        'keySelector': {
          'trafficType': 'user',
          'attribute': null
        },
        'matcherType': 'ALL_KEYS',
        'negate': false,
        'userDefinedSegmentMatcherData': null,
        'whitelistMatcherData': null,
        'unaryNumericMatcherData': null,
        'betweenMatcherData': null
      }]
    },
    'partitions': [{
      'treatment': 'off',
      'size': 100
    }]
  }]
});
var baseConfig = {
  core: {
    authorizationKey: '<fake-token-rfc>',
    key: 'nicolas@split.io'
  },
  scheduler: {
    featuresRefreshRate: 3000,
    segmentsRefreshRate: 3000,
    metricsRefreshRate: 3000,
    impressionsRefreshRate: 3000
  },
  startup: {
    readyTimeout: 10,
    requestTimeoutBeforeReady: 10,
    eventsFirstPushWindow: 3000
  }
};

function _default(fetchMock, assert) {
  assert.test(function (t) {
    // Testing when we start from scratch
    var testUrls = {
      sdk: 'https://sdk.baseurl/readyFromCacheEmpty',
      events: 'https://events.baseurl/readyFromCacheEmpty'
    };
    localStorage.clear();
    t.plan(3);
    fetchMock.get(testUrls.sdk + '/splitChanges?since=-1', {
      status: 200,
      body: _splitchangesSince.default
    });
    fetchMock.get(testUrls.sdk + '/splitChanges?since=1457552620999', {
      status: 200,
      body: _splitchangesSince2.default
    });
    fetchMock.get(testUrls.sdk + '/mySegments/nicolas@split.io', {
      status: 200,
      body: _mysegmentsNicolasSplitIo.default
    });
    fetchMock.get(testUrls.sdk + '/mySegments/nicolas2@split.io', {
      status: 200,
      body: {
        'mySegments': []
      }
    });
    fetchMock.get(testUrls.sdk + '/mySegments/nicolas3@split.io', {
      status: 200,
      body: {
        'mySegments': []
      }
    });
    var splitio = (0, _.SplitFactory)(_objectSpread({}, baseConfig, {
      core: _objectSpread({}, baseConfig.core, {
        authorizationKey: '<fake-token-rfc2>'
      }),
      storage: {
        type: 'LOCALSTORAGE',
        prefix: 'readyFromCache_1'
      },
      urls: testUrls
    }));
    var client = splitio.client();
    var client2 = splitio.client('nicolas2@split.io');
    var client3 = splitio.client('nicolas3@split.io');
    client.once(client.Event.SDK_READY_TIMED_OUT, function () {
      t.fail('It should not timeout in this scenario.');
      t.end();
    });
    client.once(client.Event.SDK_READY_FROM_CACHE, function () {
      t.fail('It should not emit SDK_READY_FROM_CACHE if there is no cache.');
      t.end();
    });
    client.on(client.Event.SDK_READY, function () {
      t.pass('It should emit SDK_READY alone, since there was no cache.');
    });
    client2.on(client.Event.SDK_READY, function () {
      t.pass('It should emit SDK_READY alone, since there was no cache.');
    });
    client3.on(client.Event.SDK_READY, function () {
      t.pass('It should emit SDK_READY alone, since there was no cache.');
    });
  });
  assert.test(function (t) {
    var testUrls = {
      sdk: 'https://sdk.baseurl/readyFromCacheWithData',
      events: 'https://events.baseurl/readyFromCacheWithData'
    };
    localStorage.clear();
    t.plan(6 * 2);
    fetchMock.get(testUrls.sdk + '/splitChanges?since=25', function () {
      return new _promise.default(function (res) {
        (0, _setTimeout2.default)(function () {
          return res({
            status: 200,
            body: _objectSpread({}, _splitchangesSince.default, {
              since: 25
            }),
            headers: {}
          });
        }, 200);
      }); // 400ms is how long it'll take to reply with Splits, no SDK_READY should be emitted before that.
    });
    fetchMock.get(testUrls.sdk + '/splitChanges?since=1457552620999', {
      status: 200,
      body: _splitchangesSince2.default
    });
    fetchMock.get(testUrls.sdk + '/mySegments/nicolas@split.io', function () {
      return new _promise.default(function (res) {
        (0, _setTimeout2.default)(function () {
          return res({
            status: 200,
            body: _mysegmentsNicolasSplitIo.default,
            headers: {}
          });
        }, 400);
      }); // First client gets segments before splits. No segment cache loading (yet)
    });
    fetchMock.get(testUrls.sdk + '/mySegments/nicolas2@split.io', function () {
      return new _promise.default(function (res) {
        (0, _setTimeout2.default)(function () {
          return res({
            status: 200,
            body: {
              'mySegments': []
            },
            headers: {}
          });
        }, 700);
      }); // Second client gets segments after 700ms
    });
    fetchMock.get(testUrls.sdk + '/mySegments/nicolas3@split.io', function () {
      return new _promise.default(function (res) {
        (0, _setTimeout2.default)(function () {
          return res({
            status: 200,
            body: {
              'mySegments': []
            },
            headers: {}
          });
        }, 1000);
      }); // Third client mySegments will come after 1s
    });
    fetchMock.postOnce(testUrls.events + '/testImpressions/bulk', 200);
    localStorage.setItem('readyFromCache_2.SPLITIO.splits.till', 25);
    localStorage.setItem('readyFromCache_2.SPLITIO.split.always_on', alwaysOnSplitInverted);
    var startTime = (0, _now.default)();
    var splitio = (0, _.SplitFactory)(_objectSpread({}, baseConfig, {
      storage: {
        type: 'LOCALSTORAGE',
        prefix: 'readyFromCache_2'
      },
      urls: testUrls,
      debug: true
    }));
    var client = splitio.client();
    var client2 = splitio.client('nicolas2@split.io');
    var client3 = splitio.client('nicolas3@split.io');
    client.once(client.Event.SDK_READY_TIMED_OUT, function () {
      t.fail('It should not timeout in this scenario.');
      t.end();
    });
    client.once(client.Event.SDK_READY_FROM_CACHE, function () {
      t.true((0, _now.default)() - startTime < 400, 'It should emit SDK_READY_FROM_CACHE on every client if there was data in the cache and we subscribe on time. Should be considerably faster than actual readiness from the cloud.');
      t.equal(client.getTreatment('always_on'), 'off', 'It should evaluate treatments with data from cache instead of control due to Input Validation');
    });
    client2.once(client.Event.SDK_READY_FROM_CACHE, function () {
      t.true((0, _now.default)() - startTime < 400, 'It should emit SDK_READY_FROM_CACHE on every client if there was data in the cache and we subscribe on time. Should be considerably faster than actual readiness from the cloud.');
      t.equal(client.getTreatment('always_on'), 'off', 'It should evaluate treatments with data from cache instead of control due to Input Validation');
    });
    client3.once(client.Event.SDK_READY_FROM_CACHE, function () {
      t.true((0, _now.default)() - startTime < 400, 'It should emit SDK_READY_FROM_CACHE on every client if there was data in the cache and we subscribe on time. Should be considerably faster than actual readiness from the cloud.');
      t.equal(client.getTreatment('always_on'), 'off', 'It should evaluate treatments with data from cache instead of control due to Input Validation');
    });
    client.on(client.Event.SDK_READY, function () {
      t.true((0, _now.default)() - startTime >= 400, 'It should emit SDK_READY too but after syncing with the cloud.');
      t.equal(client.getTreatment('always_on'), 'on', 'It should evaluate treatments with updated data after syncing with the cloud.');
    });
    client2.on(client.Event.SDK_READY, function () {
      t.true((0, _now.default)() - startTime >= 700, 'It should emit SDK_READY too but after syncing with the cloud.');
      t.equal(client.getTreatment('always_on'), 'on', 'It should evaluate treatments with updated data after syncing with the cloud.');
    });
    client3.on(client.Event.SDK_READY, function () {
      t.true((0, _now.default)() - startTime >= 1000, 'It should emit SDK_READY too but after syncing with the cloud.');
      t.equal(client.getTreatment('always_on'), 'on', 'It should evaluate treatments with updated data after syncing with the cloud.');
    });
  });
}