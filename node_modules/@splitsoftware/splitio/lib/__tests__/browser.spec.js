"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _bind = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/bind"));

var _tapeCatch = _interopRequireDefault(require("tape-catch"));

var _fetchMock = _interopRequireDefault(require("./utils/fetchMock"));

var _evaluations = _interopRequireDefault(require("./browserSuites/evaluations.spec"));

var _impressions = _interopRequireDefault(require("./browserSuites/impressions.spec"));

var _metrics = _interopRequireDefault(require("./browserSuites/metrics.spec"));

var _impressionsListener = _interopRequireDefault(require("./browserSuites/impressions-listener.spec"));

var _readiness = _interopRequireDefault(require("./browserSuites/readiness.spec"));

var _readyFromCache = _interopRequireDefault(require("./browserSuites/ready-from-cache.spec"));

var _events = require("./browserSuites/events.spec");

var _sharedInstantiation = _interopRequireDefault(require("./browserSuites/shared-instantiation.spec"));

var _manager = _interopRequireDefault(require("./browserSuites/manager.spec"));

var _ignoreIpAddressesSetting = _interopRequireDefault(require("./browserSuites/ignore-ip-addresses-setting.spec"));

var _useBeaconApi = _interopRequireDefault(require("./browserSuites/use-beacon-api.spec"));

var _settings = _interopRequireDefault(require("../utils/settings"));

var _splitchangesSince = _interopRequireDefault(require("./mocks/splitchanges.since.-1.json"));

var _splitchangesSince2 = _interopRequireDefault(require("./mocks/splitchanges.since.1457552620999.json"));

var _mysegmentsFacundoSplitIo = _interopRequireDefault(require("./mocks/mysegments.facundo@split.io.json"));

var _mysegmentsNicolasSplitIo = _interopRequireDefault(require("./mocks/mysegments.nicolas@split.io.json"));

var _mysegmentsMarcioSplitIo = _interopRequireDefault(require("./mocks/mysegments.marcio@split.io.json"));

var settings = (0, _settings.default)({
  core: {
    key: 'facundo@split.io'
  }
});
var configInMemory = {
  core: {
    authorizationKey: '<fake-token>',
    key: 'facundo@split.io'
  },
  scheduler: {
    featuresRefreshRate: 1,
    segmentsRefreshRate: 1,
    metricsRefreshRate: 3000,
    // for now I don't want to publish metrics during E2E run.
    impressionsRefreshRate: 3000 // for now I don't want to publish impressions during E2E run.

  }
};
var configInMemoryWithBucketingKey = {
  core: {
    authorizationKey: '<fake-token>',
    key: {
      matchingKey: 'facundo@split.io',
      bucketingKey: 'some_id'
    }
  },
  scheduler: {
    featuresRefreshRate: 1,
    segmentsRefreshRate: 1,
    metricsRefreshRate: 3000,
    // for now I don't want to publish metrics during E2E run.
    impressionsRefreshRate: 3000 // for now I don't want to publish impressions during E2E run.

  }
};
var configInLocalStorage = {
  core: {
    authorizationKey: '<fake-token>',
    key: 'facundo@split.io'
  },
  scheduler: {
    featuresRefreshRate: 1,
    segmentsRefreshRate: 1,
    metricsRefreshRate: 3000,
    // for now I don't want to publish metrics during E2E run.
    impressionsRefreshRate: 3000 // for now I don't want to publish impressions during E2E run.

  },
  storage: {
    type: 'LOCALSTORAGE',
    prefix: 'e2eTEST' // Avoid storage name clashes

  }
};
(0, _tapeCatch.default)('## E2E CI Tests ##', function (assert) {
  //If we change the mocks, we need to clear localstorage. Cleaning up after testing ensures "fresh data".
  localStorage.clear();

  _fetchMock.default.get(settings.url('/splitChanges?since=-1'), {
    status: 200,
    body: _splitchangesSince.default
  });

  _fetchMock.default.get(settings.url('/splitChanges?since=1457552620999'), {
    status: 200,
    body: _splitchangesSince2.default
  });

  _fetchMock.default.get(settings.url('/mySegments/facundo@split.io'), {
    status: 200,
    body: _mysegmentsFacundoSplitIo.default
  });

  _fetchMock.default.get(settings.url('/mySegments/nicolas@split.io'), {
    status: 200,
    body: _mysegmentsNicolasSplitIo.default
  });

  _fetchMock.default.get(settings.url('/mySegments/marcio@split.io'), {
    status: 200,
    body: _mysegmentsMarcioSplitIo.default
  });

  _fetchMock.default.post(settings.url('/testImpressions/bulk'), 200);
  /* Check client evaluations. */


  assert.test('E2E / In Memory', (0, _bind.default)(_evaluations.default).call(_evaluations.default, null, configInMemory, _fetchMock.default));
  assert.test('E2E / In Memory with Bucketing Key', (0, _bind.default)(_evaluations.default).call(_evaluations.default, null, configInMemoryWithBucketingKey, _fetchMock.default));
  assert.test('E2E / In LocalStorage with In Memory Fallback', (0, _bind.default)(_evaluations.default).call(_evaluations.default, null, configInLocalStorage, _fetchMock.default));
  /* Check impressions */

  assert.test('E2E / Impressions', (0, _bind.default)(_impressions.default).call(_impressions.default, null, _fetchMock.default));
  /* Check impression listener */

  assert.test('E2E / Impression listener', _impressionsListener.default);
  /* Check metrics */

  assert.test('E2E / Metrics', (0, _bind.default)(_metrics.default).call(_metrics.default, null, _fetchMock.default));
  /* Check events */

  assert.test('E2E / Events', (0, _bind.default)(_events.withoutBindingTT).call(_events.withoutBindingTT, null, _fetchMock.default));
  assert.test('E2E / Events with TT binded', (0, _bind.default)(_events.bindingTT).call(_events.bindingTT, null, _fetchMock.default));
  /* Check shared clients */

  assert.test('E2E / Shared instances', (0, _bind.default)(_sharedInstantiation.default).call(_sharedInstantiation.default, null, false, _fetchMock.default));
  assert.test('E2E / Shared instances with Traffic Type on factory settings', (0, _bind.default)(_sharedInstantiation.default).call(_sharedInstantiation.default, null, true, _fetchMock.default));
  /* Check basic manager functionality */

  assert.test('E2E / Manager API', (0, _bind.default)(_manager.default).call(_manager.default, null, settings, _fetchMock.default));
  /* Validate readiness */

  assert.test('E2E / Readiness', (0, _bind.default)(_readiness.default).call(_readiness.default, null, _fetchMock.default));
  /* Validate headers for ip and hostname are not sended with requests (ignore setting IPAddressesEnabled) */

  assert.test('E2E / Ignore setting IPAddressesEnabled', (0, _bind.default)(_ignoreIpAddressesSetting.default).call(_ignoreIpAddressesSetting.default, null, _fetchMock.default));
  /* Check that impressions and events are sended to backend via Beacon API or Fetch when page unload is triggered. */

  assert.test('E2E / Use Beacon API (or Fetch if not available) to send remaining impressions and events when browser page is unload', (0, _bind.default)(_useBeaconApi.default).call(_useBeaconApi.default, null, _fetchMock.default));
  /* Validate ready from cache behaviour (might be merged into another suite if we end up having simple behavior around it as expected) */

  assert.test('E2E / Readiness from cache', (0, _bind.default)(_readyFromCache.default).call(_readyFromCache.default, null, _fetchMock.default)); //If we change the mocks, we need to clear localstorage. Cleaning up after testing ensures "fresh data".

  localStorage.clear();
  assert.end();
});