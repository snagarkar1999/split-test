"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/web.url.to-json");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _setTimeout2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/set-timeout"));

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/json/stringify"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));

var _logger = _interopRequireDefault(require("../utils/logger"));

var _timeTracker = _interopRequireDefault(require("../utils/timeTracker"));

var _repeat = _interopRequireDefault(require("../utils/fn/repeat"));

var _events = _interopRequireDefault(require("../services/events"));

var _bulk = _interopRequireDefault(require("../services/events/bulk"));

var log = (0, _logger.default)('splitio-events');

var EventsFactory = function EventsFactory(context) {
  var settings = context.get(context.constants.SETTINGS);
  var storage = context.get(context.constants.STORAGE);

  var pushEvents = function pushEvents() {
    if (storage.events.isEmpty()) return _promise.default.resolve();
    log.info("Pushing ".concat(storage.events.state().length, " queued events."));

    var latencyTrackerStop = _timeTracker.default.start(_timeTracker.default.TaskNames.EVENTS_PUSH);

    var json = (0, _stringify.default)(storage.events.toJSON());

    var wrapUpCb = function wrapUpCb() {
      return latencyTrackerStop();
    };

    storage.events.clear(); // we always clear the queue.

    return (0, _events.default)((0, _bulk.default)(settings, {
      body: json
    })).then(wrapUpCb).catch(wrapUpCb);
  };

  var stopEventPublisherTimeout = false;
  var stopEventsPublisher = false;

  var startEventsPublisher = function startEventsPublisher() {
    return stopEventsPublisher = (0, _repeat.default)(function (schedulePublisher) {
      return pushEvents().then(function () {
        return schedulePublisher();
      });
    }, settings.scheduler.eventsPushRate);
  };

  return {
    start: function start() {
      // On the browser there may be a wish to wait an specific amount of seconds before the first push.
      if (settings.startup.eventsFirstPushWindow > 0) {
        stopEventPublisherTimeout = (0, _setTimeout2.default)(startEventsPublisher, settings.startup.eventsFirstPushWindow);
      } else {
        startEventsPublisher();
      }
    },
    flush: function flush() {
      return pushEvents();
    },
    stop: function stop() {
      stopEventPublisherTimeout && clearTimeout(stopEventPublisherTimeout);
      stopEventsPublisher && stopEventsPublisher();
    },
    flushAndResetTimer: function flushAndResetTimer() {
      // Reset the timer and push the events.
      log.info('Flushing events and reseting timer.');
      stopEventsPublisher && stopEventsPublisher.reset();
      return pushEvents();
    }
  };
};

var _default = EventsFactory;
exports.default = _default;