"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

require("core-js/modules/es.function.name");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.split");

var _indexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/index-of"));

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/json/stringify"));

var _tapeCatch = _interopRequireDefault(require("tape-catch"));

var _input = _interopRequireDefault(require("./mocks/input"));

var _output = _interopRequireDefault(require("./mocks/output"));

var _ = _interopRequireDefault(require("../"));

var _InMemory = _interopRequireDefault(require("../../storage/SplitCache/InMemory"));

var _sinon = _interopRequireDefault(require("sinon"));

var contextMock = {
  get: _sinon.default.stub().callsFake(function (entityName) {
    if (entityName === 'is_destroyed') return false;
    return {
      hasStatusManagerExtension: true
    };
  }),
  constants: {
    DESTROYED: 'is_destroyed',
    STATUS_MANAGER: 'status_manager'
  }
};
(0, _tapeCatch.default)('MANAGER API / In Memory / List all splits', function (assert) {
  var cache = new _InMemory.default();
  var manager = new _.default(cache, contextMock);
  cache.addSplit(_input.default.name, (0, _stringify.default)(_input.default));
  var views = manager.splits();
  assert.deepEqual(views[0], _output.default);
  assert.end();
});
(0, _tapeCatch.default)('MANAGER API / In Memory / Read only one split by name', function (assert) {
  var cache = new _InMemory.default();
  var manager = new _.default(cache, contextMock);
  cache.addSplit(_input.default.name, (0, _stringify.default)(_input.default));
  var split = manager.split(_input.default.name);
  assert.deepEqual(split, _output.default);
  assert.end();
});
(0, _tapeCatch.default)('MANAGER API / In Memory / List all the split names', function (assert) {
  var cache = new _InMemory.default();
  var manager = new _.default(cache, contextMock);
  cache.addSplit(_input.default.name, (0, _stringify.default)(_input.default));
  var names = manager.names();
  assert.true((0, _indexOf.default)(names).call(names, _input.default.name) !== -1);
  assert.end();
});
(0, _tapeCatch.default)('MANAGER API / In Memory / Input Validation', function (assert) {
  var cache = new _InMemory.default();
  var manager = new _.default(cache, contextMock);
  cache.addSplit(_input.default.name, (0, _stringify.default)(_input.default)); // control assertions to verify that the manager is connected with that cache.

  assert.ok(manager.split(_input.default.name), 'control assertion for split.');
  assert.ok(manager.splits().length > 0, 'control assertion for splits.');
  assert.ok(manager.names().length > 0, 'control assertion for names.');
  assert.equal(manager.split(undefined), null, 'If the split name is invalid, `manager.split(invalidName)` returns null.'); // This is kind of tied to the implementation of the isOperational validator.

  contextMock.get.returns(true);
  assert.equal(manager.split(_input.default.name), null, 'If the factory/client is destroyed, `manager.split(validName)` will return null either way since the storage is not valid.');
  assert.deepEqual(manager.splits(), [], 'If the factory/client is destroyed, `manager.splits()` will return empty array either way since the storage is not valid.');
  assert.deepEqual(manager.names(), [], 'If the factory/client is destroyed, `manager.names()` will return empty array either way since the storage is not valid.');
  assert.end();
});