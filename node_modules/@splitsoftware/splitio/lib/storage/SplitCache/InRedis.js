"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/web.dom-collections.iterator");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/toConsumableArray"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/map"));

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));

var _isNan = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/number/is-nan"));

var _parseInt2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/parse-int"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));

var _map2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/keys"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/slicedToArray"));

var _reduce = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/reduce"));

var _lang = require("../../utils/lang");

var _logger = _interopRequireDefault(require("../../utils/logger"));

var log = (0, _logger.default)('splitio-storage:redis');
/**
 * Discard errors for an answer of multiple operations.
 */

var processPipelineAnswer = function processPipelineAnswer(results) {
  return (0, _reduce.default)(results).call(results, function (accum, _ref) {
    var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
        err = _ref2[0],
        value = _ref2[1];

    if (err === null) accum.push(value);
    return accum;
  }, []);
};

var SplitCacheInRedis = /*#__PURE__*/function () {
  function SplitCacheInRedis(keys, redis) {
    var _this = this;

    (0, _classCallCheck2.default)(this, SplitCacheInRedis);
    this.redis = redis;
    this.keys = keys;
    this.redisError = false;
    this.redis.on('error', function (e) {
      _this.redisError = e;
    });
    this.redis.on('connect', function () {
      _this.redisError = false;
    });
  }

  (0, _createClass2.default)(SplitCacheInRedis, [{
    key: "addSplit",
    value: function addSplit(splitName, split) {
      return this.redis.set((0, _keys.default)(this).buildSplitKey(splitName), split).then(function (status) {
        return status === 'OK';
      });
    }
  }, {
    key: "addSplits",
    value: function addSplits(entries) {
      var _this2 = this;

      if (entries.length) {
        var cmds = (0, _map2.default)(entries).call(entries, function (_ref3) {
          var _ref4 = (0, _slicedToArray2.default)(_ref3, 2),
              key = _ref4[0],
              value = _ref4[1];

          return ['set', (0, _keys.default)(_this2).buildSplitKey(key), value];
        });
        return this.redis.pipeline(cmds).exec().then(processPipelineAnswer).then(function (answers) {
          return (0, _map2.default)(answers).call(answers, function (status) {
            return status === 'OK';
          });
        });
      } else {
        return [true];
      }
    }
    /**
     * Remove a given split from Redis. Returns the number of deleted keys.
     */

  }, {
    key: "removeSplit",
    value: function removeSplit(splitName) {
      return this.redis.del((0, _keys.default)(this).buildSplitKey(splitName));
    }
    /**
     * Bulk delete of splits from Redis. Returns the number of deleted keys.
     */

  }, {
    key: "removeSplits",
    value: function removeSplits(names) {
      var _this3 = this;

      if (names.length) {
        return this.redis.del((0, _map2.default)(names).call(names, function (n) {
          return (0, _keys.default)(_this3).buildSplitKey(n);
        }));
      } else {
        return _promise.default.resolve(0);
      }
    }
    /**
     * Get split definition or null if it's not defined.
     */

  }, {
    key: "getSplit",
    value: function getSplit(splitName) {
      if (this.redisError) {
        log.error(this.redisError);
        throw this.redisError;
      }

      return this.redis.get((0, _keys.default)(this).buildSplitKey(splitName));
    }
    /**
     * Set till number.
     *
     * @TODO pending error handling
     */

  }, {
    key: "setChangeNumber",
    value: function setChangeNumber(changeNumber) {
      return this.redis.set((0, _keys.default)(this).buildSplitsTillKey(), changeNumber + '').then(function (status) {
        return status === 'OK';
      });
    }
    /**
     * Get till number or null if it's not defined.
     *
     * @TODO pending error handling
     */

  }, {
    key: "getChangeNumber",
    value: function getChangeNumber() {
      return this.redis.get((0, _keys.default)(this).buildSplitsTillKey()).then(function (value) {
        var i = (0, _parseInt2.default)(value, 10);
        return (0, _isNan.default)(i) ? -1 : i;
      });
    }
    /**
     * @TODO we need to benchmark which is the maximun number of commands we could
     *       pipeline without kill redis performance.
     */

  }, {
    key: "getAll",
    value: function getAll() {
      var _context,
          _this4 = this;

      return (0, _keys.default)(_context = this.redis).call(_context, (0, _keys.default)(this).searchPatternForSplitKeys()).then(function (listOfKeys) {
        return _this4.redis.pipeline((0, _map2.default)(listOfKeys).call(listOfKeys, function (k) {
          return ['get', k];
        })).exec();
      }).then(processPipelineAnswer);
    }
  }, {
    key: "getKeys",
    value: function getKeys() {
      var _context2,
          _this5 = this;

      return (0, _keys.default)(_context2 = this.redis).call(_context2, (0, _keys.default)(this).searchPatternForSplitKeys()).then(function (listOfKeys) {
        return (0, _map2.default)(listOfKeys).call(listOfKeys, (0, _keys.default)(_this5).extractKey);
      });
    }
  }, {
    key: "trafficTypeExists",
    value: function trafficTypeExists(trafficType) {
      // If there is a number there should be > 0, otherwise the TT is considered as not existent.
      return this.redis.get((0, _keys.default)(this).buildTrafficTypeKey(trafficType)).then(function (ttCount) {
        ttCount = (0, _parseInt2.default)(ttCount, 10);

        if (!(0, _lang.isFinite)(ttCount) || ttCount < 0) {
          log.info("Could not validate traffic type existance of ".concat(trafficType, " due to data corruption of some sorts."));
          return false;
        }

        return ttCount > 0;
      }).catch(function (e) {
        var _context3;

        log.error((0, _concat.default)(_context3 = "Could not validate traffic type existance of ".concat(trafficType, " due to an error: ")).call(_context3, e, ".")); // If there is an error, bypass the validation so the event can get tracked.

        return true;
      });
    } // noop, just keeping the interface. This is used by client-side implementations only.

  }, {
    key: "usesSegments",
    value: function usesSegments() {
      return true;
    }
    /**
     * Delete everything in the current database.
     *
     * @NOTE documentation says it never fails.
     */

  }, {
    key: "flush",
    value: function flush() {
      return this.redis.flushdb().then(function (status) {
        return status === 'OK';
      });
    }
    /**
     * Fetches multiple splits definitions.
     */

  }, {
    key: "fetchMany",
    value: function fetchMany(splitNames) {
      var _this6 = this,
          _this$redis;

      if (this.redisError) {
        log.error(this.redisError);
        throw this.redisError;
      }

      var splits = new _map.default();
      var keys = (0, _map2.default)(splitNames).call(splitNames, function (splitName) {
        return (0, _keys.default)(_this6).buildSplitKey(splitName);
      });
      return (_this$redis = this.redis).mget.apply(_this$redis, (0, _toConsumableArray2.default)(keys)).then(function (splitDefinitions) {
        (0, _forEach.default)(splitNames).call(splitNames, function (splitName, idx) {
          splits.set(splitName, splitDefinitions[idx]);
        });
        return _promise.default.resolve(splits);
      }).catch(function (e) {
        log.error("Could not grab splits due to an error: ".concat(e, "."));
        return _promise.default.reject(e);
      });
    }
    /**
     * Check if the splits information is already stored in cache. Redis would actually be the cache.
     */

  }, {
    key: "checkCache",
    value: function checkCache() {
      return false;
    }
  }]);
  return SplitCacheInRedis;
}();

var _default = SplitCacheInRedis;
exports.default = _default;