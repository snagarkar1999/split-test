"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.to-string");

require("core-js/modules/web.dom-collections.iterator");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _indexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/index-of"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));

var _reduce = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/reduce"));

var _keys2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/keys"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));

var _logger = _interopRequireDefault(require("../../../utils/logger"));

var log = (0, _logger.default)('splitio-storage:localstorage');
var DEFINED = '1';

var SegmentCacheInLocalStorage = /*#__PURE__*/function () {
  function SegmentCacheInLocalStorage(keys) {
    (0, _classCallCheck2.default)(this, SegmentCacheInLocalStorage);
    this.keys = keys;
  }

  (0, _createClass2.default)(SegmentCacheInLocalStorage, [{
    key: "addToSegment",
    value: function addToSegment(segmentName
    /*, segmentKeys: Array<string>*/
    ) {
      var segmentKey = (0, _keys2.default)(this).buildSegmentNameKey(segmentName);

      try {
        localStorage.setItem(segmentKey, DEFINED);
        return true;
      } catch (e) {
        log.error(e);
        return false;
      }
    }
  }, {
    key: "removeFromSegment",
    value: function removeFromSegment(segmentName
    /*, segmentKeys: Array<string>*/
    ) {
      var segmentKey = (0, _keys2.default)(this).buildSegmentNameKey(segmentName);

      try {
        localStorage.removeItem(segmentKey);
        return true;
      } catch (e) {
        log.error(e);
        return false;
      }
    }
  }, {
    key: "resetSegments",
    value: function resetSegments(segmentNames) {
      var _context,
          _this = this;

      var isDiff = false;
      var index; // Scan current values from localStorage

      var storedSegmentNames = (0, _reduce.default)(_context = (0, _keys.default)(localStorage)).call(_context, function (accum, key) {
        var segmentName = (0, _keys2.default)(_this).extractSegmentName(key);
        if (segmentName) accum.push(segmentName);
        return accum;
      }, []); // Extreme fast => everything is empty

      if (segmentNames.length === 0 && storedSegmentNames.length === segmentNames.length) return isDiff; // Quick path

      if (storedSegmentNames.length !== segmentNames.length) {
        isDiff = true;
        (0, _forEach.default)(storedSegmentNames).call(storedSegmentNames, function (segmentName) {
          return _this.removeFromSegment(segmentName);
        });
        (0, _forEach.default)(segmentNames).call(segmentNames, function (segmentName) {
          return _this.addToSegment(segmentName);
        });
      } else {
        // Slowest path => we need to find at least 1 difference because
        for (index = 0; index < segmentNames.length && (0, _indexOf.default)(storedSegmentNames).call(storedSegmentNames, segmentNames[index]) !== -1; index++) {// TODO: why empty statement?
        }

        if (index < segmentNames.length) {
          isDiff = true;
          (0, _forEach.default)(storedSegmentNames).call(storedSegmentNames, function (segmentName) {
            return _this.removeFromSegment(segmentName);
          });
          (0, _forEach.default)(segmentNames).call(segmentNames, function (segmentName) {
            return _this.addToSegment(segmentName);
          });
        }
      }

      return isDiff;
    }
  }, {
    key: "isInSegment",
    value: function isInSegment(segmentName
    /*, key: string*/
    ) {
      return localStorage.getItem((0, _keys2.default)(this).buildSegmentNameKey(segmentName)) === DEFINED;
    }
  }, {
    key: "setChangeNumber",
    value: function setChangeNumber()
    /*segmentName: string, changeNumber: number*/
    {
      return true;
    }
  }, {
    key: "getChangeNumber",
    value: function getChangeNumber()
    /*segmentName: string*/
    {
      return -1;
    }
  }, {
    key: "registerSegment",
    value: function registerSegment()
    /*segment: string*/
    {
      return false;
    }
  }, {
    key: "registerSegments",
    value: function registerSegments()
    /*segments: Iterable<string>*/
    {
      return false;
    }
  }, {
    key: "getRegisteredSegments",
    value: function getRegisteredSegments() {
      return [];
    }
  }, {
    key: "flush",
    value: function flush() {
      log.info('Flushing localStorage');
      localStorage.clear();
    }
  }]);
  return SegmentCacheInLocalStorage;
}();

var _default = SegmentCacheInLocalStorage;
exports.default = _default;