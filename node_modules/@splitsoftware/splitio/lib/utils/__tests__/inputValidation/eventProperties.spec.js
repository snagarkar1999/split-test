"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/define-property"));

var _defineProperties = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/define-properties"));

var _getOwnPropertyDescriptors = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors"));

var _getOwnPropertyDescriptor = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));

var _getOwnPropertySymbols = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols"));

var _defineProperty3 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/defineProperty"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/map"));

var _symbol = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/symbol"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));

var _isFinite = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/number/is-finite"));

var _reduce = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/reduce"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));

var _tapeCatch = _interopRequireDefault(require("tape-catch"));

var _sinon = _interopRequireDefault(require("sinon"));

var _proxyquire = _interopRequireDefault(require("proxyquire"));

function ownKeys(object, enumerableOnly) { var keys = (0, _keys.default)(object); if (_getOwnPropertySymbols.default) { var symbols = (0, _getOwnPropertySymbols.default)(object); if (enumerableOnly) symbols = (0, _filter.default)(symbols).call(symbols, function (sym) { return (0, _getOwnPropertyDescriptor.default)(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context2; (0, _forEach.default)(_context2 = ownKeys(Object(source), true)).call(_context2, function (key) { (0, _defineProperty3.default)(target, key, source[key]); }); } else if (_getOwnPropertyDescriptors.default) { (0, _defineProperties.default)(target, (0, _getOwnPropertyDescriptors.default)(source)); } else { var _context3; (0, _forEach.default)(_context3 = ownKeys(Object(source))).call(_context3, function (key) { (0, _defineProperty2.default)(target, key, (0, _getOwnPropertyDescriptor.default)(source, key)); }); } } return target; }

var proxyquireStrict = _proxyquire.default.noCallThru();

var loggerMock = {
  warn: _sinon.default.stub(),
  error: _sinon.default.stub()
};

function LogFactoryMock() {
  return loggerMock;
}

var _proxyquireStrict = proxyquireStrict('../../inputValidation/eventProperties', {
  '../logger': LogFactoryMock
}),
    validateEventProperties = _proxyquireStrict.validateEventProperties;
/* We'll reset the history for the next test */


function resetStubs() {
  loggerMock.warn.resetHistory();
  loggerMock.error.resetHistory();
}

function calculateSize(obj) {
  // we calculate the expected size.
  var keys = (0, _keys.default)(obj); // each string char counts as two bytes.

  var keysSize = (0, _reduce.default)(keys).call(keys, function (accum, key) {
    return accum + key.length * 2;
  }, 0);
  var valuesSize = (0, _reduce.default)(keys).call(keys, function (accum, key) {
    if (obj[key] === null) return accum; // 0 for null

    if ((0, _isFinite.default)(obj[key])) return accum + 8; // 8 for numbers

    if (obj[key] === true || obj[key] === false) return accum + 4; // 4 for bool

    if (typeof obj[key] === 'string') return accum + obj[key].length * 2;
    return accum; // Invalid props won't count towards the size, since those should had been
  }, 0);
  return keysSize + valuesSize;
}

var invalidValues = [[], function () {}, false, true, 'something', NaN, -Infinity, Infinity, new _promise.default(function (res) {
  return res;
}), (0, _symbol.default)('asd'), new _map.default()];
(0, _tapeCatch.default)('INPUT VALIDATION for Event Properties', function (t) {
  t.test('Not setting the properties object is acceptable', function (assert) {
    assert.deepEqual(validateEventProperties(undefined, 'some_method_eventProps'), {
      properties: null,
      size: 1024
    }, 'It should return null in replacement of undefined since it is valid with default event size.');
    assert.deepEqual(validateEventProperties(undefined, 'some_method_eventProps'), {
      properties: null,
      size: 1024
    }, 'It should return the passed null since it is valid with default event size.');
    assert.notOk(loggerMock.error.called, 'Should not log any errors.');
    assert.notOk(loggerMock.warn.called, 'It should have not logged any warnings.');
    resetStubs();
    assert.end();
  });
  t.test('When setting a value for properties, only objects are acceptable', function (assert) {
    (0, _forEach.default)(invalidValues).call(invalidValues, function (val) {
      assert.deepEqual(validateEventProperties(val, 'some_method_eventProps'), {
        properties: false,
        size: 1024
      }, 'It should return default size and properties false if the properties value is not an object or null/undefined.');
      assert.ok(loggerMock.error.calledOnceWithExactly('some_method_eventProps: properties must be a plain object.'), 'Should log an error.');
      loggerMock.error.resetHistory();
    });
    assert.notOk(loggerMock.warn.called, 'It should have not logged any warnings.');
    resetStubs();
    assert.end();
  });
  t.test('It should return the properties object when valid and also the correct event size', function (assert) {
    // The events are considered to weight 1024 bytes (1kb) in average without props. Properties add to that.
    var validProperties = {
      bool: true,
      falseyBool: false,
      string: 'a string',
      number: 123,
      number2: 0.250,
      nullProp: null
    };
    var output = validateEventProperties(validProperties, 'some_method_eventProps');
    assert.deepEqual(output, {
      properties: validProperties,
      size: 1024 + calculateSize(validProperties)
    }, 'It should return the properties and the event size.');
    assert.notEqual(validProperties, output.properties, 'Returned properties should be a clone.');
    assert.notOk(loggerMock.error.called, 'Should not log any errors.');
    assert.notOk(loggerMock.warn.called, 'It should have not logged any warnings.');
    resetStubs();
    assert.end();
  });
  t.test('It should return the properties object when valid and also the correct event size, nulling any invalid prop', function (assert) {
    var _context;

    // The events are considered to weight 1024 bytes (1kb) in average without props. Properties add to that.
    var providedProperties = {
      bool: true,
      falseyBool: false,
      string: 'a string',
      number: 123,
      nullProp: null,
      willBeNulled1: function willBeNulled1() {},
      willBeNulled2: {},
      willBeNulled3: [],
      willBeNulled4: new _map.default()
    };
    var output = validateEventProperties(providedProperties, 'some_method_eventProps');
    assert.deepEqual(output, {
      properties: _objectSpread({}, providedProperties, {
        willBeNulled1: null,
        willBeNulled2: null,
        willBeNulled3: null,
        willBeNulled4: null
      }),
      size: 1024 + calculateSize(providedProperties)
    }, 'It should return the properties and the event size.');
    assert.notEqual(providedProperties, output.properties, 'Returned properties should be a clone.');
    assert.notOk(loggerMock.error.called, 'Should not log any errors.');
    assert.equal(loggerMock.warn.callCount, 4, 'It should have logged one warning per each property of the invalid type.');
    (0, _forEach.default)(_context = ['willBeNulled1', 'willBeNulled2', 'willBeNulled3', 'willBeNulled4']).call(_context, function (key) {
      assert.ok(loggerMock.warn.calledWithExactly("some_method_eventProps: Property ".concat(key, " is of invalid type. Setting value to null.")));
    });
    resetStubs();
    assert.end();
  });
  t.test('It should log a warning if the object has more than the max amount of allowed keys, logging a warning and returning the event (if other validations pass)', function (assert) {
    var validProperties = {};

    for (var i = 0; i < 300; i++) {
      validProperties[i] = null; // all will be null so we do not exceed the size.
    }

    var output = validateEventProperties(validProperties, 'some_method_eventProps');
    assert.deepEqual(output, {
      properties: validProperties,
      size: 1024 + calculateSize(validProperties)
    }, 'It should return the properties and the event size.');
    assert.notOk(loggerMock.error.called, 'Should not log any errors.');
    assert.notOk(loggerMock.warn.called, 'It should have not logged any warnings.');
    validProperties.a = null; // Adding one prop to exceed the limit.

    output = validateEventProperties(validProperties, 'some_method_eventProps');
    assert.deepEqual(output, {
      properties: validProperties,
      size: 1024 + calculateSize(validProperties)
    }, 'It should return the properties and the event size.');
    assert.notOk(loggerMock.error.called, 'Should not log any errors.');
    assert.ok(loggerMock.warn.calledOnceWithExactly('some_method_eventProps: Event has more than 300 properties. Some of them will be trimmed when processed.'), 'It should have not logged any warnings.');
    resetStubs();
    assert.end();
  });
  var fiveHundredChars = 'JKHSAKFJASHFJKASHSFKHAKJSGJKASGH1234567890JASHGJHASGJKAHSJKGHAJKSHGJKAHGJKASHajksghkjahsgjkhsakjghjkashgjkhagjkhajksghjkahsgjksahgjkahsgjkhasgjkhsagjkabsgjhaenjkrnjkwnqrkjnqwekjrnkjweqntkjnjkenasdjkngjksdajkghkjdasgkjnadsjgn asdkjgnkjsadngkjnasdjkngjknasdkjgnasdlgnsdakgnlkasndugbuoewqoitnwlkgadsgjdnsagubadisugboisdngklasdgndsgbjasdbgjkasbdgubuiqwetoiqhweiojtioweqhtiohqweiohtiowqehtoihewqiobtgoiqwengiowqnegionwqeogiqwneoignqiowegnioqewgnwqoiegnoiqwengiowqnegoinqwgionqwegionwqeoignqwegoinoiadnfaosignoiansgk';
  t.test('It should log an error and not return the properties if it exceeds the 32kb size limit', function (assert) {
    var validProperties = {};

    for (var i = 10; i < 41; i++) {
      validProperties[i] = fiveHundredChars; // key length is two, plus 510 chars it is 512 which multiplied by the byte size of each char is 1kb each key.
    } // It should be right on the size limit.


    var output = validateEventProperties(validProperties, 'some_method_eventProps');
    assert.deepEqual(output, {
      properties: validProperties,
      size: 1024 + calculateSize(validProperties)
    }, 'It should return the properties and the event size.');
    assert.notEqual(validProperties, output.properties, 'Returned properties should be a clone.');
    assert.notOk(loggerMock.error.called, 'Should not log any errors.');
    assert.notOk(loggerMock.warn.called, 'Should not log any warnings.');
    validProperties.a = null; // exceed by two bytes (1 char string key which is two bytes, null value which we count as 0 to match other SDKs)

    output = validateEventProperties(validProperties, 'some_method_eventProps');
    assert.deepEqual(output, {
      properties: false,
      size: 1024 * 32 + 2 // the two extra bytes.

    }, 'It should return false instead of the properties and the event size.');
    assert.notOk(loggerMock.warn.called, 'Should not log any warnings.');
    assert.ok(loggerMock.error.calledOnceWithExactly('some_method_eventProps: The maximum size allowed for the properties is 32768 bytes, which was exceeded. Event not queued.'), 'Should not log any errors.');
    loggerMock.error.resetHistory();
    resetStubs();
    assert.end();
  });
});