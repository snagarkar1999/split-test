"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty2 = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

_Object$defineProperty2(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/define-property"));

var _defineProperties = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/define-properties"));

var _getOwnPropertyDescriptors = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _getOwnPropertyDescriptor = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));

var _getOwnPropertySymbols = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));

var _defineProperty3 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/defineProperty"));

var _create = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/create"));

var _assign = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/assign"));

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));

var _lang = require("../lang");

var _language = _interopRequireDefault(require("./language"));

var _runtime = _interopRequireDefault(require("./runtime"));

var _defaults = _interopRequireDefault(require("./defaults"));

var _storage = _interopRequireDefault(require("./storage"));

var _integrations = _interopRequireDefault(require("./integrations"));

var _mode = _interopRequireDefault(require("./mode"));

var _logger = require("../../utils/logger");

var _constants = require("../../utils/constants");

var _package = require("../../../package.json");

var _context;

function ownKeys(object, enumerableOnly) { var keys = (0, _keys.default)(object); if (_getOwnPropertySymbols.default) { var symbols = (0, _getOwnPropertySymbols.default)(object); if (enumerableOnly) symbols = (0, _filter.default)(symbols).call(symbols, function (sym) { return (0, _getOwnPropertyDescriptor.default)(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context6; (0, _forEach.default)(_context6 = ownKeys(Object(source), true)).call(_context6, function (key) { (0, _defineProperty3.default)(target, key, source[key]); }); } else if (_getOwnPropertyDescriptors.default) { (0, _defineProperties.default)(target, (0, _getOwnPropertyDescriptors.default)(source)); } else { var _context7; (0, _forEach.default)(_context7 = ownKeys(Object(source))).call(_context7, function (key) { (0, _defineProperty2.default)(target, key, (0, _getOwnPropertyDescriptor.default)(source, key)); }); } } return target; }

var eventsEndpointMatcher = /^\/(testImpressions|metrics|events)/;
var authEndpointMatcher = /^\/auth/;
var streamingEndpointMatcher = /^\/(sse|event-stream)/;
var base = {
  // Define which kind of object you want to retrieve from SplitFactory
  mode: _constants.STANDALONE_MODE,
  core: {
    // API token (tight to an environment)
    authorizationKey: undefined,
    // key used in your system (only required for browser version)
    key: undefined,
    // traffic type for the given key (only used on browser version)
    trafficType: undefined,
    // toggle impressions tracking of labels
    labelsEnabled: true,
    // toggle sendind (true) or not sending (false) IP and Host Name with impressions, events, and telemetries requests (only used on nodejs version)
    IPAddressesEnabled: undefined
  },
  scheduler: {
    // fetch feature updates each 30 sec
    featuresRefreshRate: 30,
    // fetch segments updates each 60 sec
    segmentsRefreshRate: 60,
    // publish metrics each 120 sec
    metricsRefreshRate: 120,
    // publish evaluations each 60 sec
    impressionsRefreshRate: 60,
    // fetch offline changes each 15 sec
    offlineRefreshRate: 15,
    // publish events every 60 seconds after the first flush
    eventsPushRate: 60,
    // how many events will be queued before flushing
    eventsQueueSize: 500,
    // backoff base seconds to wait before re attempting to authenticate for push notifications
    authRetryBackoffBase: 1,
    // backoff base seconds to wait before re attempting to connect to streaming
    streamingReconnectBackoffBase: 1
  },
  urls: {
    // CDN having all the information for your environment
    sdk: 'https://sdk.split.io/api',
    // Storage for your SDK events
    events: 'https://events.split.io/api',
    // SDK Auth Server
    auth: 'https://auth.split.io/api',
    // Streaming Server
    streaming: 'https://streaming.split.io'
  },
  // Defines which kind of storage we should instanciate.
  storage: {
    type: _constants.STORAGE_MEMORY
  },
  // Defines if the logs are enabled, SDK wide.
  debug: undefined,
  // Defines the impression listener, but will only be used on NodeJS.
  impressionListener: undefined,
  // Instance version.
  version: (0, _concat.default)(_context = "".concat(_language.default, "-")).call(_context, _package.version),
  // List of integrations.
  integrations: undefined,
  // toggle using (true) or not using (false) Server-Side Events for synchronizing storage
  streamingEnabled: false
};

function fromSecondsToMillis(n) {
  return Math.round(n * 1000);
}

function setupLogger(debugValue) {
  if (typeof debugValue === 'boolean') {
    if (debugValue) {
      _logger.API.enable();
    } else {
      _logger.API.disable();
    }
  } else if (typeof debugValue === 'string') {
    _logger.API.setLogLevel(debugValue);
  }
}

function defaults(custom) {
  var withDefaults = (0, _lang.merge)({}, base, _defaults.default, custom); // Scheduler periods

  withDefaults.scheduler.featuresRefreshRate = fromSecondsToMillis(withDefaults.scheduler.featuresRefreshRate);
  withDefaults.scheduler.segmentsRefreshRate = fromSecondsToMillis(withDefaults.scheduler.segmentsRefreshRate);
  withDefaults.scheduler.metricsRefreshRate = fromSecondsToMillis(withDefaults.scheduler.metricsRefreshRate);
  withDefaults.scheduler.impressionsRefreshRate = fromSecondsToMillis(withDefaults.scheduler.impressionsRefreshRate);
  withDefaults.scheduler.offlineRefreshRate = fromSecondsToMillis(withDefaults.scheduler.offlineRefreshRate);
  withDefaults.scheduler.eventsPushRate = fromSecondsToMillis(withDefaults.scheduler.eventsPushRate); // Startup periods

  withDefaults.startup.requestTimeoutBeforeReady = fromSecondsToMillis(withDefaults.startup.requestTimeoutBeforeReady);
  withDefaults.startup.readyTimeout = fromSecondsToMillis(withDefaults.startup.readyTimeout);
  withDefaults.startup.eventsFirstPushWindow = fromSecondsToMillis(withDefaults.startup.eventsFirstPushWindow); // ensure a valid SDK mode

  withDefaults.mode = (0, _mode.default)(withDefaults.core.authorizationKey, withDefaults.mode); // ensure a valid Storage based on mode defined.

  withDefaults.storage = (0, _storage.default)(withDefaults);
  setupLogger(withDefaults.debug); // Current ip/hostname information

  withDefaults.runtime = (0, _runtime.default)(withDefaults.core.IPAddressesEnabled, withDefaults.mode === _constants.CONSUMER_MODE); // ensure a valid list of integrations.
  // `integrations` returns an array of valid integration items.

  withDefaults.integrations = (0, _integrations.default)(withDefaults); // validate push options

  if (!(0, _lang.isBoolean)(withDefaults.streamingEnabled)) withDefaults.streamingEnabled = false;

  if (withDefaults.streamingEnabled) {
    // Backoff bases.
    // We are not checking if bases are positive numbers. Thus, we might be reauthenticating immediately (`setTimeout` with NaN or negative number)
    withDefaults.scheduler.authRetryBackoffBase = fromSecondsToMillis(withDefaults.scheduler.authRetryBackoffBase);
    withDefaults.scheduler.streamingReconnectBackoffBase = fromSecondsToMillis(withDefaults.scheduler.streamingReconnectBackoffBase);
  }

  return withDefaults;
}

var proto = {
  /**
   * Switch URLs servers based on target.
   *
   * @param {String} target url target
   * @return {String} completed url
   */
  url: function url(target) {
    var _context5;

    if (eventsEndpointMatcher.test(target)) {
      var _context2;

      return (0, _concat.default)(_context2 = "".concat(this.urls.events)).call(_context2, target);
    }

    if (authEndpointMatcher.test(target)) {
      var _context3;

      return (0, _concat.default)(_context3 = "".concat(this.urls.auth)).call(_context3, target);
    }

    if (streamingEndpointMatcher.test(target)) {
      var _context4;

      return (0, _concat.default)(_context4 = "".concat(this.urls.streaming)).call(_context4, target);
    }

    return (0, _concat.default)(_context5 = "".concat(this.urls.sdk)).call(_context5, target);
  },

  /**
   * Returns a settings clone with the key and traffic type (if provided) overriden.
   * @param {SplitKey} key
   * @param {string} [trafficType]
   */
  overrideKeyAndTT: function overrideKeyAndTT(key, trafficType) {
    return (0, _assign.default)((0, _create.default)(proto), _objectSpread({}, this, {
      core: _objectSpread({}, this.core, {
        key: key,
        trafficType: trafficType
      })
    }));
  }
};

var SettingsFactory = function SettingsFactory(settings) {
  return (0, _assign.default)((0, _create.default)(proto), defaults(settings));
};

var _default = SettingsFactory;
exports.default = _default;