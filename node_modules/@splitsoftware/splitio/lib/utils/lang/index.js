"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

require("core-js/modules/es.function.name");

require("core-js/modules/es.number.constructor");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.match");

require("core-js/modules/es.string.replace");

require("core-js/modules/es.string.split");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.startsWith = startsWith;
exports.endsWith = endsWith;
exports.get = get;
exports.findIndex = findIndex;
exports.find = find;
exports.isString = isString;
exports.isFinite = isFinite;
exports.uniqueId = uniqueId;
exports.isObject = isObject;
exports.merge = merge;
exports.uniq = uniq;
exports.unicAsStrings = unicAsStrings;
exports.toString = toString;
exports.toNumber = toNumber;
exports.forOwn = forOwn;
exports.groupBy = groupBy;
exports.getFnName = getFnName;
exports.shallowClone = shallowClone;
exports.isBoolean = isBoolean;

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/json/stringify"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));

var _splice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/splice"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/typeof"));

var _isFinite = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/number/is-finite"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/array/is-array"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));

/**
 * Checks if the target string starts with the sub string.
 */
function startsWith(target, sub) {
  if (!(isString(target) && isString(sub))) {
    return false;
  }

  return (0, _slice.default)(target).call(target, 0, sub.length) === sub;
}
/**
 * Checks if the target string ends with the sub string.
 */


function endsWith(target, sub) {
  var caseInsensitive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (!(isString(target) && isString(sub))) {
    return false;
  }

  if (caseInsensitive) {
    target = target.toLowerCase();
    sub = sub.toLowerCase();
  }

  return (0, _slice.default)(target).call(target, target.length - sub.length) === sub;
}
/**
 * Safely retrieve the specified prop from obj. If we can't retrieve
 * that property value, we return the default value.
 */


function get(obj, prop, val) {
  var res = val;

  try {
    // No risks nor lots of checks.
    var pathPieces = prop.split('.');
    var partial = obj;
    (0, _forEach.default)(pathPieces).call(pathPieces, function (pathPiece) {
      return partial = partial[pathPiece];
    });
    if (typeof partial !== 'undefined') res = partial;
  } catch (e) {// noop
  }

  return res;
}
/**
 * Evaluates iteratee for each element of the source array. Returns the index of the first element
 * for which iteratee returns truthy. If no element is found or there's an issue with the params it returns -1.
 */


function findIndex(source, iteratee) {
  if ((0, _isArray.default)(source) && typeof iteratee === 'function') {
    for (var i = 0; i < source.length; i++) {
      if (iteratee(source[i], i, source) === true) {
        return i;
      }
    }
  }

  return -1;
}
/**
 * Loops through a source collection (an object or an array) running iteratee
 * against each element. It returns the first element for which iteratee returned
 * a truthy value and stops the loop.
 * Iteratee receives three arguments (element, key/index, collection)
 */


function find(source, iteratee) {
  var res;

  if (isObject(source)) {
    var keys = (0, _keys.default)(source);

    for (var i = 0; i < keys.length && !res; i++) {
      var key = keys[i];
      var iterateeResult = iteratee(source[key], key, source);
      if (iterateeResult) res = source[key];
    }
  } else if ((0, _isArray.default)(source)) {
    for (var _i = 0; _i < source.length && !res; _i++) {
      var _iterateeResult = iteratee(source[_i], _i, source);

      if (_iterateeResult) res = source[_i];
    }
  }

  return res;
}
/**
 * Checks if a given value is a string.
 */


function isString(val) {
  return typeof val === 'string' || val instanceof String;
}
/**
 * Checks if a given value is a finite number.
 */


function isFinite(val) {
  if (typeof val === 'number') return (0, _isFinite.default)(val);
  if (val instanceof Number) return (0, _isFinite.default)(val.valueOf());
  return false;
}

var uniqueIdCounter = -1;
/**
 * Returns a number to be used as ID, which will be unique.
 */

function uniqueId() {
  return uniqueIdCounter++;
}
/**
 * Validates if a value is an object.
 */


function isObject(obj) {
  return obj && (0, _typeof2.default)(obj) === 'object' && obj.constructor === Object;
}
/**
 * There are some assumptions here. It's for internal use and we don't need verbose errors
 * or to ensure the data types or whatever. Parameters should always be correct (at least have a target and a source, of type object).
 */


function merge(target, source) {
  var _context;

  var res = target;
  isObject(source) && (0, _forEach.default)(_context = (0, _keys.default)(source)).call(_context, function (key) {
    var val = source[key];

    if (isObject(val)) {
      if (res[key] && isObject(res[key])) {
        // If both are objects, merge into a new one.
        val = merge({}, res[key], val);
      } else {
        // else make a copy.
        val = merge({}, val);
      }
    } // We skip undefined values.


    if (val !== undefined) res[key] = val;
  });

  for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    rest[_key - 2] = arguments[_key];
  }

  if (rest && rest.length) {
    var _context2;

    var nextSource = (0, _splice.default)(rest).call(rest, 0, 1)[0];
    res = merge.apply(void 0, (0, _concat.default)(_context2 = [res, nextSource]).call(_context2, rest));
  }

  return res;
}
/**
 * Removes duplicate items on an array of strings.
 */


function uniq(arr) {
  var seen = {};
  return (0, _filter.default)(arr).call(arr, function (item) {
    return Object.prototype.hasOwnProperty.call(seen, item) ? false : seen[item] = true;
  });
}
/**
 * Removes duplicate items on an array of objects using an optional `stringify` function as equality criteria.
 * It uses JSON.stringify as default criteria.
 */


function unicAsStrings(arr) {
  var stringify = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _stringify.default;
  var seen = {};
  return (0, _filter.default)(arr).call(arr, function (item) {
    var itemString = stringify(item);
    return Object.prototype.hasOwnProperty.call(seen, itemString) ? false : seen[itemString] = true;
  });
}
/**
 * Transforms a value into it's string representation.
 */


function toString(val) {
  if (val == null) return '';
  if (typeof val === 'string') return val;
  if ((0, _isArray.default)(val)) return (0, _map.default)(val).call(val, function (val) {
    return isString(val) ? val : '';
  }) + '';
  var result = val + '';
  return result === '0' && 1 / val === Number.NEGATIVE_INFINITY ? '-0' : result;
}
/**
 * Transforms a value into a number.
 * Note: We're not expecting anything fancy here. If we are at some point, add more type checks.
 */


function toNumber(val) {
  if (typeof val === 'number') return val;

  if (isObject(val) && typeof val.valueOf === 'function') {
    var valOf = val.valueOf();
    val = isObject(valOf) ? valOf + '' : valOf;
  }

  if (typeof val !== 'string') {
    return val === 0 ? val : +val;
  } // Remove trailing whitespaces.


  val = val.replace(/^\s+|\s+$/g, '');
  return +val;
}
/**
 * Executes iteratee for given obj own props.
 */


function forOwn(obj, iteratee) {
  var keys = (0, _keys.default)(obj);
  (0, _forEach.default)(keys).call(keys, function (key) {
    return iteratee(obj[key], key, obj);
  });
  return obj;
}
/**
 * Parses an array into a map of different arrays, grouping by the specified prop value.
 */


function groupBy(source, prop) {
  var map = {};

  if ((0, _isArray.default)(source) && isString(prop)) {
    for (var i = 0; i < source.length; i++) {
      var key = source[i][prop]; // Skip the element if the key is not a string.

      if (isString(key)) {
        if (!map[key]) map[key] = [];
        map[key].push(source[i]);
      }
    }
  }

  return map;
}
/**
 * Returns the name of a given function.
 */


function getFnName(fn) {
  if (fn.name) return fn.name;
  return (fn.toString().match(/function (.+?)\(/) || ['', ''])[1];
}
/**
 * Shallow clone an object
 */


function shallowClone(obj) {
  var keys = (0, _keys.default)(obj);
  var output = {};

  for (var i = 0; i < keys.length; i++) {
    output[keys[i]] = obj[keys[i]];
  }

  return output;
}

function isBoolean(val) {
  return val === true || val === false;
}