"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/define-property"));

var _defineProperties = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/define-properties"));

var _getOwnPropertyDescriptors = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _getOwnPropertyDescriptor = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));

var _getOwnPropertySymbols = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));

var _defineProperty3 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/defineProperty"));

var _now = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/date/now"));

var _tape = _interopRequireDefault(require("tape"));

var _SplitToGa = _interopRequireDefault(require("../SplitToGa"));

var _constants = require("../../../utils/constants");

var _gaMock3 = require("./gaMock");

function ownKeys(object, enumerableOnly) { var keys = (0, _keys.default)(object); if (_getOwnPropertySymbols.default) { var symbols = (0, _getOwnPropertySymbols.default)(object); if (enumerableOnly) symbols = (0, _filter.default)(symbols).call(symbols, function (sym) { return (0, _getOwnPropertyDescriptor.default)(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context; (0, _forEach.default)(_context = ownKeys(Object(source), true)).call(_context, function (key) { (0, _defineProperty3.default)(target, key, source[key]); }); } else if (_getOwnPropertyDescriptors.default) { (0, _defineProperties.default)(target, (0, _getOwnPropertyDescriptors.default)(source)); } else { var _context2; (0, _forEach.default)(_context2 = ownKeys(Object(source))).call(_context2, function (key) { (0, _defineProperty2.default)(target, key, (0, _getOwnPropertyDescriptor.default)(source, key)); }); } } return target; }

var fakeImpressionPayload = {
  impression: {
    feature: 'hierarchical_splits_test',
    keyName: 'nicolas@split.io',
    treatment: 'on',
    bucketingKey: undefined,
    label: 'expected label'
  },
  attributes: undefined,
  ip: 'ip',
  hostname: 'hostname',
  sdkLanguageVersion: 'version'
};
var fakeImpression = {
  type: _constants.SPLIT_IMPRESSION,
  payload: fakeImpressionPayload
};
var defaultImpressionFieldsObject = {
  hitType: 'event',
  eventCategory: 'split-impression',
  eventAction: 'Evaluate ' + fakeImpressionPayload.impression.feature,
  eventLabel: 'Treatment: ' + fakeImpressionPayload.impression.treatment + '. Targeting rule: ' + fakeImpressionPayload.impression.label + '.',
  nonInteraction: true
};
var fakeEventPayload = {
  eventTypeId: 'eventTypeId',
  trafficTypeName: 'trafficTypeName',
  value: 0,
  timestamp: (0, _now.default)(),
  key: 'key',
  properties: undefined
};
var fakeEvent = {
  type: _constants.SPLIT_EVENT,
  payload: fakeEventPayload
};
var defaultEventFieldsObject = {
  hitType: 'event',
  eventCategory: 'split-event',
  eventAction: fakeEventPayload.eventTypeId,
  eventValue: fakeEventPayload.value,
  nonInteraction: true
};
(0, _tape.default)('SplitToGa', function (t) {
  t.test('SplitToGa.validateFieldsObject', function (assert) {
    assert.equal(_SplitToGa.default.validateFieldsObject(undefined), false);
    assert.equal(_SplitToGa.default.validateFieldsObject(null), false);
    assert.equal(_SplitToGa.default.validateFieldsObject(123), false);
    assert.equal(_SplitToGa.default.validateFieldsObject(true), false);
    assert.equal(_SplitToGa.default.validateFieldsObject('something'), false);
    assert.equal(_SplitToGa.default.validateFieldsObject(/asd/ig), false);
    assert.equal(_SplitToGa.default.validateFieldsObject(function () {}), false);
    assert.equal(_SplitToGa.default.validateFieldsObject({}), false, 'An empty object is an invalid FieldsObject instance');
    assert.equal(_SplitToGa.default.validateFieldsObject({
      hitType: 10
    }), true, 'A fields object instance must have a HitType');
    assert.equal(_SplitToGa.default.validateFieldsObject({
      hitType: 'event',
      ignoredProp: 'ignoredProp'
    }), true, 'A fields object instance must have a HitType');
    assert.end();
  });
  t.test('SplitToGa.defaultMapper', function (assert) {
    assert.deepEqual(_SplitToGa.default.defaultMapper(fakeImpression), defaultImpressionFieldsObject, 'should return the corresponding FieldsObject for a given impression');
    assert.deepEqual(_SplitToGa.default.defaultMapper(fakeEvent), defaultEventFieldsObject, 'should return the corresponding FieldsObject for a given event');
    assert.end();
  });
  t.test('SplitToGa.getGa', function (assert) {
    var _gaMock = (0, _gaMock3.gaMock)(),
        ga = _gaMock.ga;

    assert.equal(_SplitToGa.default.getGa(), ga, 'should return ga command queue if it exists');
    (0, _gaMock3.gaRemove)();
    assert.equal(_SplitToGa.default.getGa(), undefined, 'should return undefined if ga command queue does not exist');
    assert.end();
  });
  t.test('SplitToGa (constructor and queue method)', function (assert) {
    // test setup
    var _gaMock2 = (0, _gaMock3.gaMock)(),
        ga = _gaMock2.ga;
    /** Default behaviour **/


    var instance = new _SplitToGa.default();
    instance.queue(fakeImpression);
    assert.true(ga.lastCall.calledWithExactly('send', _objectSpread({}, defaultImpressionFieldsObject, {
      splitHit: true
    })), 'should queue `ga send` with the default mapped FieldsObject for impressions, appended with `splitHit` field');
    instance.queue(fakeEvent);
    assert.true(ga.lastCall.calledWithExactly('send', _objectSpread({}, defaultEventFieldsObject, {
      splitHit: true
    })), 'should queue `ga send` with the default mapped FieldsObject for events, appended with `splitHit` field');
    assert.equal(ga.callCount, 2);
    /** Custom behaviour **/
    // Custom filter

    function customFilter(data) {
      return data.type === _constants.SPLIT_EVENT;
    } // Custom mapper that returns a new FieldsObject instance


    function customMapper() {
      return {
        hitType: 'event',
        someField: 'someField'
      };
    }

    var trackerNames = ['', 'namedTracker'];
    var instance2 = new _SplitToGa.default({
      filter: customFilter,
      mapper: customMapper,
      trackerNames: trackerNames
    });
    ga.resetHistory();
    instance2.queue(fakeImpression);
    assert.true(ga.notCalled, 'shouldn\'t queue `ga send` if a Split data (impression or event) is filtered');
    instance2.queue(fakeEvent);
    assert.true(ga.calledWithExactly('send', _objectSpread({}, customMapper(fakeImpression, defaultImpressionFieldsObject), {
      splitHit: true
    })), 'should queue `ga send` with the custom trackerName and FieldsObject from customMapper, appended with `splitHit` field');
    assert.true(ga.calledWithExactly("".concat(trackerNames[1], ".send"), _objectSpread({}, customMapper(fakeEvent, defaultEventFieldsObject), {
      splitHit: true
    })), 'should queue `ga send` with the custom trackerName and FieldsObject from customMapper, appended with `splitHit` field');
    assert.equal(ga.callCount, 2); // Custom mapper that returns the default FieldsObject

    function customMapper2(data, defaultFieldsObject) {
      return defaultFieldsObject;
    }

    var instance3 = new _SplitToGa.default({
      mapper: customMapper2
    });
    ga.resetHistory();
    instance3.queue(fakeImpression);
    assert.true(ga.lastCall.calledWithExactly('send', _objectSpread({}, customMapper2(fakeImpression, defaultImpressionFieldsObject), {
      splitHit: true
    })), 'should queue `ga send` with the custom FieldsObject from customMapper2, appended with `splitHit` field');
    assert.equal(ga.callCount, 1); // Custom mapper that throws an error

    function customMapper3() {
      throw 'some error';
    }

    var instance4 = new _SplitToGa.default({
      mapper: customMapper3
    });
    ga.resetHistory();
    instance4.queue(fakeImpression);
    assert.true(ga.notCalled, 'shouldn\'t queue `ga send` if a custom mapper throw an exception'); // `impressions` flags

    var instance5 = new _SplitToGa.default({
      impressions: false
    });
    ga.resetHistory();
    instance5.queue(fakeImpression);
    assert.true(ga.notCalled, 'shouldn\'t queue `ga send` for an impression if `impressions` flag is false'); // `impressions` flags

    var instance6 = new _SplitToGa.default({
      events: false
    });
    ga.resetHistory();
    instance6.queue(fakeEvent);
    assert.true(ga.notCalled, 'shouldn\'t queue `ga send` for a event if `events` flag is false'); // test teardown

    (0, _gaMock3.gaRemove)();
    assert.end();
  });
});