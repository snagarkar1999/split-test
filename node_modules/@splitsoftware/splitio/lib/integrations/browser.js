"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _GaToSplit = _interopRequireDefault(require("./ga/GaToSplit"));

var _SplitToGa = _interopRequireDefault(require("./ga/SplitToGa"));

var _constants = require("../utils/constants");

/**
 * Factory function for browser IntegrationsManager.
 * The integrations manager instantiates integration modules, and bypass tracked events and impressions to them.
 *
 * @param {Context} context SplitFactory context
 *
 * @returns integration manager or null if `integrations` are not present in settings.
 */
var integrationsManagerFactory = function integrationsManagerFactory(context) {
  var _context;

  var settings = context.get(context.constants.SETTINGS);
  var listeners = []; // No need to check if `settings.integrations` is an array. It was already validated in settings validation

  (0, _forEach.default)(_context = settings.integrations).call(_context, function (integrationOptions) {
    var type = integrationOptions.type;
    var integration;

    switch (type) {
      case _constants.GOOGLE_ANALYTICS_TO_SPLIT:
        {
          var storage = context.get(context.constants.STORAGE);
          var coreSettings = settings.core;
          integration = (0, _GaToSplit.default)(integrationOptions, storage, coreSettings);
          break;
        }

      case _constants.SPLIT_TO_GOOGLE_ANALYTICS:
        {
          integration = new _SplitToGa.default(integrationOptions);
          break;
        }
    }

    if (integration && integration.queue) listeners.push(integration);
  }); // If `listeners` is empty, not return a integration manager

  if (listeners.length === 0) return; // Exception safe methods: each integration module is responsable for handling errors

  return {
    handleImpression: function handleImpression(impressionData) {
      (0, _forEach.default)(listeners).call(listeners, function (listener) {
        return listener.queue({
          type: _constants.SPLIT_IMPRESSION,
          payload: impressionData
        });
      });
    },
    handleEvent: function handleEvent(eventData) {
      (0, _forEach.default)(listeners).call(listeners, function (listener) {
        return listener.queue({
          type: _constants.SPLIT_EVENT,
          payload: eventData
        });
      });
    }
  };
};

var _default = integrationsManagerFactory;
exports.default = _default;