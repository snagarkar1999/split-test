import _someInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/some";
import _Object$keys from "@babel/runtime-corejs3/core-js-stable/object/keys";
import _typeof from "@babel/runtime-corejs3/helpers/esm/typeof";
import { isObject, forOwn } from '../../../utils/lang';
import parseCondition from './parseCondition';
var previousMock = {
  'emptyMock': 1
};

function hasTreatmentChanged(prev, curr) {
  if (_typeof(prev) !== _typeof(curr)) return true;

  if (typeof prev === 'string') {
    // strings treatments, just compare
    return prev !== curr;
  } else {
    // has treatment and config, compare both
    return prev.treatment !== curr.treatment || prev.config !== curr.config;
  }
}

function mockUpdated(currentData) {
  var names = _Object$keys(currentData); // Different amount of items


  if (names.length !== _Object$keys(previousMock).length) {
    previousMock = currentData;
    return true;
  }

  return _someInstanceProperty(names).call(names, function (name) {
    var newSplit = !previousMock[name];
    var newTreatment = hasTreatmentChanged(previousMock[name], currentData[name]);
    var changed = newSplit || newTreatment;
    if (changed) previousMock = currentData;
    return changed;
  });
}

function getConfigurationFromSettings(settings) {
  var mockSettings = settings.features || {};
  if (!mockUpdated(mockSettings)) return false;
  var splitObjects = {};
  forOwn(mockSettings, function (data, splitName) {
    var treatment = data;
    var config = null;

    if (isObject(data)) {
      treatment = data.treatment;
      config = data.config || config;
    }

    var configurations = {};
    if (config !== null) configurations[treatment] = config;
    splitObjects[splitName] = {
      conditions: [parseCondition({
        treatment: treatment
      })],
      configurations: configurations
    };
  });
  return splitObjects;
}

export default getConfigurationFromSettings;