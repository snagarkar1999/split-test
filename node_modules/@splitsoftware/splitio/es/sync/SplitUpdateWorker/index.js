import _bindInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/bind";
import _classCallCheck from "@babel/runtime-corejs3/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime-corejs3/helpers/esm/createClass";
import Backoff from '../../utils/backoff';
/**
 * SplitUpdateWorker class
 */

var SplitUpdateWorker = /*#__PURE__*/function () {
  /**
   * @param {Object} splitStorage splits cache
   * @param {Object} splitProducer node producer or full browser producer
   * @param {Object} splitsEventEmitter
   */
  function SplitUpdateWorker(splitStorage, splitProducer, splitsEventEmitter) {
    var _context, _context2, _context3;

    _classCallCheck(this, SplitUpdateWorker);

    this.splitStorage = splitStorage;
    this.splitProducer = splitProducer;
    this.maxChangeNumber = 0;
    this.splitsEventEmitter = splitsEventEmitter;
    this.put = _bindInstanceProperty(_context = this.put).call(_context, this);
    this.killSplit = _bindInstanceProperty(_context2 = this.killSplit).call(_context2, this);
    this.__handleSplitUpdateCall = _bindInstanceProperty(_context3 = this.__handleSplitUpdateCall).call(_context3, this);
    this.backoff = new Backoff(this.__handleSplitUpdateCall);
  } // Private method
  // Preconditions: this.splitProducer.isSynchronizingSplits === false


  _createClass(SplitUpdateWorker, [{
    key: "__handleSplitUpdateCall",
    value: function __handleSplitUpdateCall() {
      var _this = this;

      if (this.maxChangeNumber > this.splitStorage.getChangeNumber()) {
        this.handleNewEvent = false;
        this.splitProducer.synchronizeSplits().then(function () {
          if (_this.handleNewEvent) {
            _this.__handleSplitUpdateCall();
          } else {
            _this.backoff.scheduleCall();
          }
        });
      }
    }
    /**
     * Invoked by NotificationProcessor on SPLIT_UPDATE event
     *
     * @param {number} changeNumber change number of the SPLIT_UPDATE notification
     */

  }, {
    key: "put",
    value: function put(changeNumber) {
      var currentChangeNumber = this.splitStorage.getChangeNumber();
      if (changeNumber <= currentChangeNumber || changeNumber <= this.maxChangeNumber) return;
      this.maxChangeNumber = changeNumber;
      this.handleNewEvent = true;
      this.backoff.reset();
      if (this.splitProducer.isSynchronizingSplits()) return;

      this.__handleSplitUpdateCall();
    }
    /**
     * Invoked by NotificationProcessor on SPLIT_KILL event
     *
     * @param {number} changeNumber change number of the SPLIT_UPDATE notification
     * @param {string} splitName name of split to kill
     * @param {string} defaultTreatment default treatment value
     */

  }, {
    key: "killSplit",
    value: function killSplit(changeNumber, splitName, defaultTreatment) {
      var _this2 = this;

      // @TODO handle retry due to errors in storage, once we allow the definition of custom async storages
      this.splitStorage.killLocally(splitName, defaultTreatment, changeNumber).then(function (updated) {
        // trigger an SDK_UPDATE if Split was killed locally
        if (updated) _this2.splitsEventEmitter.emit(_this2.splitsEventEmitter.SDK_SPLITS_ARRIVED, true); // queues the SplitChanges fetch (only if changeNumber is newer)

        _this2.put(changeNumber);
      });
    }
  }]);

  return SplitUpdateWorker;
}();

export { SplitUpdateWorker as default };