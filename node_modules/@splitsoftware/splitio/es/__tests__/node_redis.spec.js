import _Object$defineProperty from "@babel/runtime-corejs3/core-js-stable/object/define-property";
import _Object$defineProperties from "@babel/runtime-corejs3/core-js-stable/object/define-properties";
import _Object$getOwnPropertyDescriptors from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _Object$getOwnPropertyDescriptor from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor";
import _filterInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/filter";
import _Object$getOwnPropertySymbols from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols";
import _Object$keys from "@babel/runtime-corejs3/core-js-stable/object/keys";
import _defineProperty from "@babel/runtime-corejs3/helpers/esm/defineProperty";
import _setTimeout from "@babel/runtime-corejs3/core-js-stable/set-timeout";
import _regeneratorRuntime from "@babel/runtime-corejs3/regenerator";
import _typeof from "@babel/runtime-corejs3/helpers/esm/typeof";
import _asyncToGenerator from "@babel/runtime-corejs3/helpers/esm/asyncToGenerator";
import _Promise from "@babel/runtime-corejs3/core-js-stable/promise";

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context6; _forEachInstanceProperty(_context6 = ownKeys(Object(source), true)).call(_context6, function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { var _context7; _forEachInstanceProperty(_context7 = ownKeys(Object(source))).call(_context7, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

/* eslint-disable no-console */
import osFunction from 'os';
import ipFunction from 'ip';
import tape from 'tape';
import sinon from 'sinon';
import RedisServer from 'redis-server';
import RedisClient from 'ioredis';
import { exec } from 'child_process';
import { SplitFactory } from '../';
import { merge } from '../utils/lang';
import KeyBuilder from '../storage/Keys';
import SettingsFactory from '../utils/settings';
var IP_VALUE = ipFunction.address();
var HOSTNAME_VALUE = osFunction.hostname();
var NA = 'NA';
var redisPort = '6385';
var config = {
  core: {
    authorizationKey: 'uoj4sb69bjv7d4d027f7ukkitd53ek6a9ai9'
  },
  urls: {
    sdk: 'https://sdk-aws-staging.split.io/api',
    events: 'https://events-aws-staging.split.io/api'
  },
  mode: 'consumer',
  storage: {
    type: 'REDIS',
    prefix: 'REDIS_NODE_UT',
    options: {
      url: "redis://localhost:".concat(redisPort, "/0")
    }
  },
  startup: {
    readyTimeout: 36000 // 10hs

  }
};
/**
 * Initialize redis server and run a cli bash command to load redis with data to do the proper tests
 */

var initializeRedisServer = function initializeRedisServer() {
  // Simply pass the port that you want a Redis server to listen on.
  var server = new RedisServer(redisPort);
  var promise = new _Promise(function (resolve, reject) {
    server.open().then(function () {
      exec("cat ./src/__tests__/mocks/redis-commands.txt | redis-cli -p ".concat(redisPort), function (err) {
        if (err) {
          reject(server); // node couldn't execute the command

          return;
        }

        resolve(server);
      });
    });
  });
  return promise;
};

tape('NodeJS Redis', function (t) {
  t.test('Regular usage', function (assert) {
    initializeRedisServer().then( /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(server) {
        var expectedConfig, sdk, client;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                expectedConfig = '{"color":"brown"}';
                sdk = SplitFactory(config);
                client = sdk.client();
                _context.t0 = assert;
                _context.next = 6;
                return client.getTreatment('UT_Segment_member', 'UT_IN_SEGMENT');

              case 6:
                _context.t1 = _context.sent;

                _context.t0.equal.call(_context.t0, _context.t1, 'on', 'Evaluations using Redis storage should be correct.');

                _context.t2 = assert;
                _context.next = 11;
                return client.getTreatment('other', 'UT_IN_SEGMENT');

              case 11:
                _context.t3 = _context.sent;

                _context.t2.equal.call(_context.t2, _context.t3, 'off', 'Evaluations using Redis storage should be correct.');

                _context.t4 = assert;
                _context.next = 16;
                return client.getTreatment('UT_Segment_member', 'UT_NOT_IN_SEGMENT');

              case 16:
                _context.t5 = _context.sent;

                _context.t4.equal.call(_context.t4, _context.t5, 'off', 'Evaluations using Redis storage should be correct.');

                _context.t6 = assert;
                _context.next = 21;
                return client.getTreatment('other', 'UT_NOT_IN_SEGMENT');

              case 21:
                _context.t7 = _context.sent;

                _context.t6.equal.call(_context.t6, _context.t7, 'on', 'Evaluations using Redis storage should be correct.');

                _context.t8 = assert;
                _context.next = 26;
                return client.getTreatment('UT_Segment_member', 'UT_SET_MATCHER', {
                  permissions: ['admin']
                });

              case 26:
                _context.t9 = _context.sent;

                _context.t8.equal.call(_context.t8, _context.t9, 'on', 'Evaluations using Redis storage should be correct.');

                _context.t10 = assert;
                _context.next = 31;
                return client.getTreatment('UT_Segment_member', 'UT_SET_MATCHER', {
                  permissions: ['not_matching']
                });

              case 31:
                _context.t11 = _context.sent;

                _context.t10.equal.call(_context.t10, _context.t11, 'off', 'Evaluations using Redis storage should be correct.');

                _context.t12 = assert;
                _context.next = 36;
                return client.getTreatment('UT_Segment_member', 'UT_NOT_SET_MATCHER', {
                  permissions: ['create']
                });

              case 36:
                _context.t13 = _context.sent;

                _context.t12.equal.call(_context.t12, _context.t13, 'off', 'Evaluations using Redis storage should be correct.');

                _context.t14 = assert;
                _context.next = 41;
                return client.getTreatment('UT_Segment_member', 'UT_NOT_SET_MATCHER', {
                  permissions: ['not_matching']
                });

              case 41:
                _context.t15 = _context.sent;

                _context.t14.equal.call(_context.t14, _context.t15, 'on', 'Evaluations using Redis storage should be correct.');

                _context.t16 = assert;
                _context.next = 46;
                return client.getTreatmentWithConfig('UT_Segment_member', 'UT_NOT_SET_MATCHER', {
                  permissions: ['not_matching']
                });

              case 46:
                _context.t17 = _context.sent;
                _context.t18 = {
                  treatment: 'on',
                  config: null
                };

                _context.t16.deepEqual.call(_context.t16, _context.t17, _context.t18, 'Evaluations using Redis storage should be correct, including configs.');

                _context.t19 = assert;
                _context.next = 52;
                return client.getTreatmentWithConfig('UT_Segment_member', 'always-on-with-config');

              case 52:
                _context.t20 = _context.sent;
                _context.t21 = {
                  treatment: 'on',
                  config: expectedConfig
                };

                _context.t19.deepEqual.call(_context.t19, _context.t20, _context.t21, 'Evaluations using Redis storage should be correct, including configs.');

                _context.t22 = assert;
                _context.next = 58;
                return client.getTreatment('UT_Segment_member', 'always-on');

              case 58:
                _context.t23 = _context.sent;

                _context.t22.equal.call(_context.t22, _context.t23, 'on', 'Evaluations using Redis storage should be correct.');

                _context.t24 = assert;
                _context.next = 63;
                return client.getTreatment('UT_Segment_member', 'hierarchical_splits_testing_on');

              case 63:
                _context.t25 = _context.sent;

                _context.t24.equal.call(_context.t24, _context.t25, 'on', 'Evaluations using Redis storage should be correct.');

                _context.t26 = assert;
                _context.next = 68;
                return client.getTreatment('UT_Segment_member', 'hierarchical_splits_testing_off');

              case 68:
                _context.t27 = _context.sent;

                _context.t26.equal.call(_context.t26, _context.t27, 'off', 'Evaluations using Redis storage should be correct.');

                _context.t28 = assert;
                _context.next = 73;
                return client.getTreatment('UT_Segment_member', 'hierarchical_splits_testing_on_negated');

              case 73:
                _context.t29 = _context.sent;

                _context.t28.equal.call(_context.t28, _context.t29, 'off', 'Evaluations using Redis storage should be correct.');

                assert.equal(_typeof(client.track('nicolas@split.io', 'user', 'test.redis.event', 18).then), 'function', 'Track calls should always return a promise on Redis mode.');
                assert.equal(_typeof(client.track().then), 'function', 'Track calls should always return a promise on Redis mode, even when parameters are incorrect.');
                _context.t30 = assert;
                _context.next = 80;
                return client.track('nicolas@split.io', 'user', 'test.redis.event', 18);

              case 80:
                _context.t31 = _context.sent;

                _context.t30["true"].call(_context.t30, _context.t31, 'If the event was succesfully queued the promise will resolve to true');

                _context.t32 = assert;
                _context.next = 85;
                return client.track();

              case 85:
                _context.t33 = _context.sent;

                _context.t32["false"].call(_context.t32, _context.t33, 'If the event was NOT succesfully queued the promise will resolve to false');

                _context.next = 89;
                return client.destroy();

              case 89:
                // close server connection
                server.close().then(assert.end);

              case 90:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());
  });
  t.test('Connection error', function (assert) {
    initializeRedisServer().then(function (server) {
      var sdk = SplitFactory(config);
      var client = sdk.client();
      client.once(client.Event.SDK_READY_TIMED_OUT, assert.fail);
      client.once(client.Event.SDK_READY, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.t0 = assert;
                _context3.next = 3;
                return client.getTreatment('UT_Segment_member', 'UT_NOT_SET_MATCHER', {
                  permissions: ['create']
                });

              case 3:
                _context3.t1 = _context3.sent;

                _context3.t0.equal.call(_context3.t0, _context3.t1, 'off', 'Control assertion - Everything working as expected.');

                _context3.t2 = assert;
                _context3.next = 8;
                return client.getTreatment('UT_Segment_member', 'UT_NOT_SET_MATCHER', {
                  permissions: ['not_matching']
                });

              case 8:
                _context3.t3 = _context3.sent;

                _context3.t2.equal.call(_context3.t2, _context3.t3, 'on', 'Control assertion - Everything working as expected.');

                _context3.t4 = assert;
                _context3.next = 13;
                return client.getTreatment('UT_Segment_member', 'always-on');

              case 13:
                _context3.t5 = _context3.sent;

                _context3.t4.equal.call(_context3.t4, _context3.t5, 'on', 'Control assertion - Everything working as expected.');

                _context3.t6 = assert;
                _context3.next = 18;
                return client.track('nicolas@split.io', 'user', 'test.redis.event', 18);

              case 18:
                _context3.t7 = _context3.sent;

                _context3.t6["true"].call(_context3.t6, _context3.t7, 'Control assertion - Everything working as expected.');

                _context3.t8 = assert;
                _context3.next = 23;
                return client.track();

              case 23:
                _context3.t9 = _context3.sent;

                _context3.t8.notEqual.call(_context3.t8, _context3.t9, 'Control assertion - Everything working as expected.');

                // close server connection
                server.close().then(function () {
                  // we need to add a delay before doing a getTreatment
                  _setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
                    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            _context2.t0 = assert;
                            _context2.next = 3;
                            return client.getTreatment('UT_Segment_member', 'UT_NOT_SET_MATCHER', {
                              permissions: ['create']
                            });

                          case 3:
                            _context2.t1 = _context2.sent;

                            _context2.t0.equal.call(_context2.t0, _context2.t1, 'control', 'In the event of a Redis error like a disconnection, getTreatments should not hang but resolve to "control".');

                            _context2.t2 = assert;
                            _context2.next = 8;
                            return client.getTreatment('UT_Segment_member', 'UT_NOT_SET_MATCHER', {
                              permissions: ['not_matching']
                            });

                          case 8:
                            _context2.t3 = _context2.sent;

                            _context2.t2.equal.call(_context2.t2, _context2.t3, 'control', 'In the event of a Redis error like a disconnection, getTreatments should not hang but resolve to "control".');

                            _context2.t4 = assert;
                            _context2.next = 13;
                            return client.getTreatment('UT_Segment_member', 'always-on');

                          case 13:
                            _context2.t5 = _context2.sent;

                            _context2.t4.equal.call(_context2.t4, _context2.t5, 'control', 'In the event of a Redis error like a disconnection, getTreatments should not hang but resolve to "control".');

                            _context2.t6 = assert;
                            _context2.next = 18;
                            return client.track('nicolas@split.io', 'user', 'test.redis.event', 18);

                          case 18:
                            _context2.t7 = _context2.sent;

                            _context2.t6["false"].call(_context2.t6, _context2.t7, 'In the event of a Redis error like a disconnection, track should resolve to false.');

                            _context2.next = 22;
                            return client.destroy();

                          case 22:
                            assert.end();

                          case 23:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  })), 1000);
                });

              case 26:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      })));
    });
  });
  t.test('Calling destroy with pending operations', function (assert) {
    initializeRedisServer().then( /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(server) {
        var sdk, client;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                sdk = SplitFactory(_objectSpread({}, config, {
                  debug: 'WARN' // we want to see the error/warning logs calling the actual log method (if there's any)

                }));
                client = sdk.client();
                _context4.prev = 2;
                _context4.next = 5;
                return client.ready();

              case 5:
                _context4.next = 10;
                break;

              case 7:
                _context4.prev = 7;
                _context4.t0 = _context4["catch"](2);
                assert.fail(_context4.t0);

              case 10:
                process.on('unhandledRejection', assert.fail);
                process.on('uncaughtException', assert.fail);
                sinon.spy(console, 'log');
                _context4.next = 15;
                return client.getTreatment('Tito_the_skeleton', 'always-on');

              case 15:
                client.destroy();

                _setTimeout(function () {
                  process.off('unhandledRejection', assert.fail);
                  process.off('uncaughtException', assert.fail);
                  assert.pass('Check unhandledRejection or uncaughtException detected. None is expected');
                  assert["false"](console.log.calledWithMatch('threw or exceeded configured timeout of 5000ms setting. Message: Error: Stream isn\'t writeable and enableOfflineQueue options is false'), 'No error should have been triggered from Redis.');
                  console.log.restore(); // close server connection and wrap up.

                  server.close().then(assert.end);
                }, 2000);

              case 17:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, null, [[2, 7]]);
      }));

      return function (_x2) {
        return _ref4.apply(this, arguments);
      };
    }());
  });
  t.test('Check IP and Hostname in Redis', function (assert) {
    initializeRedisServer().then( /*#__PURE__*/function () {
      var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(server) {
        var configs, _i, _configs, _config, setting, connection, keys, eventKey, impressionsKey, sdk, client, redisImpressions, parsedImpression, redisEvents, parsedEvent;

        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                configs = [config, merge({}, config, {
                  core: {
                    IPAddressesEnabled: true
                  }
                }), merge({}, config, {
                  core: {
                    IPAddressesEnabled: false
                  }
                })];
                _i = 0, _configs = configs;

              case 2:
                if (!(_i < _configs.length)) {
                  _context5.next = 38;
                  break;
                }

                _config = _configs[_i];
                // Redis client and keys required to check Redis store.
                setting = SettingsFactory(_config);
                connection = new RedisClient(setting.storage.options.url);
                keys = new KeyBuilder(setting);
                eventKey = keys.buildEventsKey();
                impressionsKey = keys.buildImpressionsKey(); // Clean up list of events and impressions.

                connection.del(eventKey);
                connection.del(impressionsKey); // Init Split client for current config

                sdk = SplitFactory(_config);
                client = sdk.client(); // Perform client actions to store a single event and impression objects into Redis

                _context5.next = 15;
                return client.getTreatment('UT_Segment_member', 'UT_IN_SEGMENT');

              case 15:
                _context5.next = 17;
                return client.track('nicolas@split.io', 'user', 'test.redis.event', 18);

              case 17:
                _context5.next = 19;
                return connection.lrange(eventKey, 0, -1);

              case 19:
                redisImpressions = _context5.sent;
                assert.equal(redisImpressions.length, 1, 'After getting a treatment, we should have one impression on Redis.');
                parsedImpression = JSON.parse(redisImpressions[0]);
                assert.equal(parsedImpression.m.i, setting.core.IPAddressesEnabled ? IP_VALUE : NA, "If IPAddressesEnabled is true, the property .m.i of the impression object must be equal to the machine ip, or \"".concat(NA, "\" otherwise."));
                assert.equal(parsedImpression.m.n, setting.core.IPAddressesEnabled ? HOSTNAME_VALUE : NA, "If IPAddressesEnabled is true, the property .m.n of the impression object must be equal to the machine hostname, or \"".concat(NA, "\" otherwise.")); // Assert if the event object was stored properly

                _context5.next = 26;
                return connection.lrange(eventKey, 0, -1);

              case 26:
                redisEvents = _context5.sent;
                assert.equal(redisEvents.length, 1, 'After tracking an event, we should have one event on Redis.');
                parsedEvent = JSON.parse(redisEvents[0]);
                assert.equal(parsedEvent.m.i, setting.core.IPAddressesEnabled ? IP_VALUE : NA, "If IPAddressesEnabled is true, the property .m.i of the event object must be equal to the machine ip, or \"".concat(NA, "\" otherwise."));
                assert.equal(parsedEvent.m.n, setting.core.IPAddressesEnabled ? HOSTNAME_VALUE : NA, "If IPAddressesEnabled is true, the property .m.n of the event object must be equal to the machine hostname, or \"".concat(NA, "\" otherwise.")); // Deallocate Split and Redis clients

                _context5.next = 33;
                return client.destroy();

              case 33:
                _context5.next = 35;
                return connection.quit();

              case 35:
                _i++;
                _context5.next = 2;
                break;

              case 38:
                // close server connection
                server.close().then(assert.end);

              case 39:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));

      return function (_x3) {
        return _ref5.apply(this, arguments);
      };
    }());
  });
});