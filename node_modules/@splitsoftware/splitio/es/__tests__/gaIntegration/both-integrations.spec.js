import _Object$defineProperty from "@babel/runtime-corejs3/core-js-stable/object/define-property";
import _Object$defineProperties from "@babel/runtime-corejs3/core-js-stable/object/define-properties";
import _Object$getOwnPropertyDescriptors from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors";
import _Object$getOwnPropertyDescriptor from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor";
import _Object$getOwnPropertySymbols from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols";
import _Object$keys from "@babel/runtime-corejs3/core-js-stable/object/keys";
import _defineProperty from "@babel/runtime-corejs3/helpers/esm/defineProperty";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _filterInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/filter";
import _regeneratorRuntime from "@babel/runtime-corejs3/regenerator";
import _setTimeout from "@babel/runtime-corejs3/core-js-stable/set-timeout";
import _reduceInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/reduce";

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context5; _forEachInstanceProperty(_context5 = ownKeys(Object(source), true)).call(_context5, function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { var _context6; _forEachInstanceProperty(_context6 = ownKeys(Object(source))).call(_context6, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { SplitFactory } from '../..';
import SettingsFactory from '../../utils/settings';
import { gaSpy, gaTag } from './gaTestUtils';
import includes from 'lodash/includes';

function countImpressions(parsedImpressionsBulkPayload) {
  return _reduceInstanceProperty(parsedImpressionsBulkPayload).call(parsedImpressionsBulkPayload, function (accumulator, currentValue) {
    return accumulator + currentValue.keyImpressions.length;
  }, 0);
}

var config = {
  core: {
    key: 'facundo@split.io',
    trafficType: 'user'
  },
  integrations: [{
    type: 'GOOGLE_ANALYTICS_TO_SPLIT'
  }, {
    type: 'SPLIT_TO_GOOGLE_ANALYTICS'
  }]
};
var settings = SettingsFactory(config);
export default function (fetchMock, assert) {
  var client; // test default behavior of both integrations

  assert.test(function (t) {
    var customHits = [{
      hitType: 'pageview'
    }, {
      hitType: 'event'
    }];
    var splitTrackParams = [['some_event'], ['other_event'], ['another_event']];
    var splitGetTreatmentParams = [['hierarchical_splits_test']]; // Generator to synchronize the call of t.end() when both impressions and events endpoints were invoked.

    var finish = /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var totalHits;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return;

            case 2:
              totalHits = customHits.length + splitTrackParams.length + splitGetTreatmentParams.length;
              t.equal(window.gaSpy.getHits().length, totalHits, 'Total hits');

              _setTimeout(function () {
                client.destroy();
                t.end();
              }, 0);

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })();

    fetchMock.postOnce(settings.url('/testImpressions/bulk'), function (url, opts) {
      // we can assert payload and ga hits, once ga is ready and after `SplitToGa.queue`, that is timeout wrapped, make to the queue stack.
      window.ga(function () {
        _setTimeout(function () {
          try {
            var _context2;

            var resp = JSON.parse(opts.body);
            var numberOfSentImpressions = countImpressions(resp);

            var sentImpressionHits = _filterInstanceProperty(_context2 = window.gaSpy.getHits()).call(_context2, function (hit) {
              return hit.eventCategory === 'split-impression';
            });

            t.equal(numberOfSentImpressions, splitGetTreatmentParams.length, 'Number of impressions');
            t.equal(sentImpressionHits.length, splitGetTreatmentParams.length, "Number of sent impression hits must be equal to the number of impressions (".concat(splitGetTreatmentParams.length, ")"));
            finish.next();
          } catch (err) {
            console.error(err);
          }
        });
      });
      return 200;
    });
    fetchMock.postOnce(settings.url('/events/bulk'), function (url, opts) {
      window.ga(function () {
        _setTimeout(function () {
          try {
            var _context3, _context4;

            var sentEvents = JSON.parse(opts.body);

            var sentEventsFromSplitToGa = _filterInstanceProperty(sentEvents).call(sentEvents, function (event) {
              return event.properties && event.properties.eventCategory && includes(event.properties.eventCategory, 'split');
            });

            t.equal(sentEvents.length, splitTrackParams.length + customHits.length, 'Number of sent events is equal to custom events plus hits tracked as events');
            t.equal(sentEventsFromSplitToGa.length, 0, 'GA hits comming from Split-to-GA integration must not be tracked again as Split events');

            var sentHitsNoSplitData = _filterInstanceProperty(_context3 = window.gaSpy.getHits()).call(_context3, function (hit) {
              return !hit.eventCategory || !includes(hit.eventCategory, 'split');
            });

            var sentHitsSplitEvents = _filterInstanceProperty(_context4 = window.gaSpy.getHits()).call(_context4, function (hit) {
              return hit.eventCategory === 'split-event';
            });

            t.equal(sentHitsNoSplitData.length, customHits.length, 'Number of custom hits');
            t.equal(sentHitsSplitEvents.length, splitTrackParams.length, 'Number of Split event hits');
            finish.next();
          } catch (err) {
            console.error(err);
          }
        });
      });
      return 200;
    });
    gaTag(); // siteSpeedSampleRate set to 0 to never send a site speed timing hit

    window.ga('create', 'UA-00000000-1', 'auto', {
      siteSpeedSampleRate: 0
    });
    gaSpy();
    window.ga('require', 'splitTracker');

    _forEachInstanceProperty(customHits).call(customHits, function (hit) {
      window.ga('send', hit);
    });

    var factory = SplitFactory(_objectSpread({}, config, {
      startup: {
        eventsFirstPushWindow: 0
      },
      scheduler: {
        impressionsRefreshRate: 1,
        // @TODO eventsPushRate is too high, but using eventsQueueSize don't let us assert `filterSplitToGaHits`
        eventsPushRate: 10 // eventsQueueSize: splitTrackParams.length + customHits.length,

      }
    }));
    client = factory.client();
    client.ready().then(function () {
      _forEachInstanceProperty(splitTrackParams).call(splitTrackParams, function (trackParams) {
        client.track.apply(client, trackParams);
      });

      _forEachInstanceProperty(splitGetTreatmentParams).call(splitGetTreatmentParams, function (getTreatmentParams) {
        client.getTreatment.apply(client, getTreatmentParams);
      });
    });
  });
}