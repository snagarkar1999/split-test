import _Object$defineProperty from "@babel/runtime-corejs3/core-js-stable/object/define-property";
import _Object$defineProperties from "@babel/runtime-corejs3/core-js-stable/object/define-properties";
import _Object$getOwnPropertyDescriptors from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _Object$getOwnPropertyDescriptor from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor";
import _filterInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/filter";
import _Object$getOwnPropertySymbols from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols";
import _Object$keys from "@babel/runtime-corejs3/core-js-stable/object/keys";
import _Date$now from "@babel/runtime-corejs3/core-js-stable/date/now";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";
import _setTimeout from "@babel/runtime-corejs3/core-js-stable/set-timeout";
import _defineProperty from "@babel/runtime-corejs3/helpers/esm/defineProperty";
import _bindInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/bind";

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context6; _forEachInstanceProperty(_context6 = ownKeys(Object(source), true)).call(_context6, function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { var _context7; _forEachInstanceProperty(_context7 = ownKeys(Object(source))).call(_context7, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

/* eslint-disable no-console */
import path from 'path';
import tape from 'tape-catch';
import sinon from 'sinon';
import fetchMock from '../utils/fetchMock';
import { SplitFactory } from '../../';
import SettingsFactory from '../../utils/settings';
var settings = SettingsFactory({
  core: {
    key: 'facundo@split.io'
  }
});
var spySplitChanges = sinon.spy();
var spySegmentChanges = sinon.spy();
var spyMySegments = sinon.spy();
var spyEventsBulk = sinon.spy();
var spyTestImpressionsBulk = sinon.spy();
var spyMetricsTimes = sinon.spy();
var spyMetricsCounters = sinon.spy();
var spyAny = sinon.spy(); // helper function that should call the spy function and return a 200 to keep
// going the fetch request flow

var replySpy = function replySpy(spy) {
  spy();
  return 200;
};

var configMocks = function configMocks() {
  fetchMock.mock(new RegExp("".concat(settings.url('/splitChanges/'), ".*")), function () {
    return replySpy(spySplitChanges);
  });
  fetchMock.mock(new RegExp("".concat(settings.url('/segmentChanges/'), ".*")), function () {
    return replySpy(spySegmentChanges);
  });
  fetchMock.mock(new RegExp("".concat(settings.url('/mySegments/'), ".*")), function () {
    return replySpy(spyMySegments);
  });
  fetchMock.mock(settings.url('/events/bulk'), function () {
    return replySpy(spyEventsBulk);
  });
  fetchMock.mock(settings.url('/testImpressions/bulk'), function () {
    return replySpy(spyTestImpressionsBulk);
  });
  fetchMock.mock(settings.url('/metrics/times'), function () {
    return replySpy(spyMetricsTimes);
  });
  fetchMock.mock(settings.url('/metrics/counters'), function () {
    return replySpy(spyMetricsCounters);
  });
  fetchMock.mock('*', function () {
    return replySpy(spyAny);
  });
};

var settingsGenerator = function settingsGenerator(mockFileName) {
  return {
    core: {
      authorizationKey: 'localhost'
    },
    scheduler: {
      impressionsRefreshRate: 0.01,
      eventsPushRate: 0.01,
      metricsRefreshRate: 0.01,
      offlineRefreshRate: 0.3
    },
    startup: {
      eventsFirstPushWindow: 0,
      readyTimeout: 3,
      retriesOnFailureBeforeReady: 0
    },
    features: path.join(__dirname, mockFileName)
  };
};

tape('NodeJS Offline Mode', function (t) {
  t.test('Old format evaluations - .split', DotSplitTests);
  t.test('New format evaluations - .yaml extension', _bindInstanceProperty(DotYAMLTests).call(DotYAMLTests, null, 'split', 'yaml'));
  t.test('New format evaluations - .yml extension', _bindInstanceProperty(DotYAMLTests).call(DotYAMLTests, null, 'split2', 'yml'));
  t.test('Old format manager - .split extension', ManagerDotSplitTests);
  t.test('New format manager - .yaml extension', _bindInstanceProperty(ManagerDotYamlTests).call(ManagerDotYamlTests, null, 'split.yaml'));
  t.test('New format manager - .yml extension', _bindInstanceProperty(ManagerDotYamlTests).call(ManagerDotYamlTests, null, 'split2.yml'));
  t.test('Trying to specify an invalid extension it will timeout', function (assert) {
    var config = settingsGenerator('.forbidden');
    sinon.spy(console, 'log');
    var factory = SplitFactory(_objectSpread({}, config, {
      debug: 'ERROR'
    })); // enable error level logs to check the message.

    var client = factory.client();
    client.on(client.Event.SDK_READY, function () {
      assert.fail('If tried to load a file with invalid extension, we should not get SDK_READY.');
      client.destroy();
      assert.end();
    });
    client.on(client.Event.SDK_READY_TIMED_OUT, function () {
      assert.pass('If tried to load a file with invalid extension, we should emit SDK_READY_TIMED_OUT.');
      assert.ok(console.log.calledWithMatch("[ERROR] splitio-producer:offline => There was an issue loading the mock Splits data, no changes will be applied to the current cache. Invalid extension specified for Splits mock file. Accepted extensions are \".yml\" and \".yaml\". Your specified file is ".concat(config.features)));
      console.log.restore();
      client.destroy();
      assert.end();
    });
  });
});

function networkAssertions(client, assert) {
  return client.destroy().then(function () {
    // We test the breakdown instead of just the misc because it's faster to spot where the issue is
    assert.notOk(spySplitChanges.called, 'On offline mode we should not call the splitChanges endpoint.');
    assert.notOk(spySegmentChanges.called, 'On offline mode we should not call the segmentChanges endpoint.');
    assert.notOk(spyMySegments.called, 'On offline mode we should not call the mySegments endpoint.');
    assert.notOk(spyEventsBulk.called, 'On offline mode we should not call the events endpoint.');
    assert.notOk(spyTestImpressionsBulk.called, 'On offline mode we should not call the impressions endpoint.');
    assert.notOk(spyMetricsTimes.called, 'On offline mode we should not call the metric times endpoint.');
    assert.notOk(spyMetricsCounters.called, 'On offline mode we should not call the metric counters endpoint.');
    assert.notOk(spyAny.called, 'On offline mode we should NOT call to ANY endpoint, we are completely isolated from BE.');
  });
}

function DotSplitTests(assert) {
  configMocks();
  var config = settingsGenerator('.split');
  var factory = SplitFactory(config);
  var client = factory.client(); // Tracking some events to test they are not flushed.

  client.track('a_key', 'a_tt', 'an_ev_id');
  client.track('another_key', 'another_tt', 'another_ev_id', 25);
  client.on(client.Event.SDK_READY, function () {
    assert.equal(client.getTreatment('qa-user', 'testing_split'), 'on');
    assert.equal(client.getTreatment('qa-user', 'testing_split_2'), 'control');
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'testing_split'), {
      treatment: 'on',
      config: null
    });
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'testing_split_2'), {
      treatment: 'control',
      config: null
    });
    assert.deepEqual(client.getTreatments('qa-user', ['testing_split', 'testing_split2', 'testing_split3', 'testing_not_exist']), {
      testing_split: 'on',
      testing_split2: 'off',
      testing_split3: 'custom_treatment',
      testing_not_exist: 'control'
    });
    assert.deepEqual(client.getTreatmentsWithConfig('qa-user', ['testing_split', 'testing_split2', 'testing_split3', 'testing_not_exist']), {
      testing_split: {
        treatment: 'on',
        config: null
      },
      testing_split2: {
        treatment: 'off',
        config: null
      },
      testing_split3: {
        treatment: 'custom_treatment',
        config: null
      },
      testing_not_exist: {
        treatment: 'control',
        config: null
      }
    });

    _setTimeout(function () {
      factory.settings.features = path.join(__dirname, '.split');
    }, 290);

    _setTimeout(function () {
      factory.settings.features = path.join(__dirname, '.split');
    }, 590);

    _setTimeout(function () {
      factory.settings.features = path.join(__dirname, '.split');
    }, 890);

    _setTimeout(function () {
      factory.settings.features = path.join(__dirname, 'update.split');
    }, 1000);

    client.once(client.Event.SDK_UPDATE, function () {
      assert.equal(client.getTreatment('qa-user', 'testing_split4'), 'updated_treatment');
      networkAssertions(client, assert).then(function () {
        client.destroy().then(assert.end);
      });
    });
  });
}

function DotYAMLTests(mockFileName, mockFileExt, assert) {
  var _context;

  configMocks();
  var config = settingsGenerator(_concatInstanceProperty(_context = "".concat(mockFileName, ".")).call(_context, mockFileExt));
  var factory = SplitFactory(config);
  var client = factory.client(); // Tracking some events to test they are not flushed.

  assert["true"](client.track('a_key', 'a_tt', 'an_ev_id'));
  assert["true"](client.track('another_key', 'another_tt', 'another_ev_id', 25));
  assert["false"](client.track('wasa', {}, [], 'invalid_stuff'));
  client.on(client.Event.SDK_READY, function () {
    assert.equal(client.getTreatment('qa-user', 'testing_split_on'), 'on');
    assert.equal(client.getTreatment('qa-user', 'testing_split_only_wl'), 'control');
    assert.equal(client.getTreatment('key_for_wl', 'testing_split_only_wl'), 'whitelisted');
    assert.equal(client.getTreatment('qa-user', 'testing_split_with_wl'), 'not_in_whitelist');
    assert.equal(client.getTreatment('key_for_wl', 'testing_split_with_wl'), 'one_key_wl');
    assert.equal(client.getTreatment('key_for_wl_1', 'testing_split_with_wl'), 'multi_key_wl');
    assert.equal(client.getTreatment('key_for_wl_2', 'testing_split_with_wl'), 'multi_key_wl');
    assert.equal(client.getTreatment('qa-user', 'testing_split_off_with_config'), 'off');
    assert.equal(client.getTreatment('qa-user', 'not_existent'), 'control');
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'testing_split_on'), {
      treatment: 'on',
      config: null
    });
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'testing_split_only_wl'), {
      treatment: 'control',
      config: null
    });
    assert.deepEqual(client.getTreatmentWithConfig('key_for_wl', 'testing_split_only_wl'), {
      treatment: 'whitelisted',
      config: null
    });
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'testing_split_with_wl'), {
      treatment: 'not_in_whitelist',
      config: '{"color": "green"}'
    });
    assert.deepEqual(client.getTreatmentWithConfig('key_for_wl', 'testing_split_with_wl'), {
      treatment: 'one_key_wl',
      config: null
    });
    assert.deepEqual(client.getTreatmentWithConfig('key_for_wl_1', 'testing_split_with_wl'), {
      treatment: 'multi_key_wl',
      config: '{"color": "brown"}'
    });
    assert.deepEqual(client.getTreatmentWithConfig('key_for_wl_2', 'testing_split_with_wl'), {
      treatment: 'multi_key_wl',
      config: '{"color": "brown"}'
    });
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'testing_split_off_with_config'), {
      treatment: 'off',
      config: '{"color": "green"}'
    });
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'not_existent'), {
      treatment: 'control',
      config: null
    });
    assert.deepEqual(client.getTreatments('qa-user', ['testing_split_on', 'testing_split_only_wl', 'testing_split_with_wl', 'testing_split_off_with_config', 'testing_not_exist']), {
      testing_split_on: 'on',
      testing_split_only_wl: 'control',
      testing_split_with_wl: 'not_in_whitelist',
      testing_split_off_with_config: 'off',
      testing_not_exist: 'control'
    });
    assert.deepEqual(client.getTreatmentsWithConfig('key_for_wl', ['testing_split_on', 'testing_split_only_wl', 'testing_split_with_wl', 'testing_split_off_with_config', 'testing_not_exist']), {
      testing_split_on: {
        treatment: 'on',
        config: null
      },
      testing_split_only_wl: {
        treatment: 'whitelisted',
        config: null
      },
      testing_split_with_wl: {
        treatment: 'one_key_wl',
        config: null
      },
      testing_split_off_with_config: {
        treatment: 'off',
        config: '{"color": "green"}'
      },
      testing_not_exist: {
        treatment: 'control',
        config: null
      }
    });

    var readyTimestamp = _Date$now();

    _setTimeout(function () {
      var _context2;

      factory.settings.features = path.join(__dirname, _concatInstanceProperty(_context2 = "".concat(mockFileName, ".")).call(_context2, mockFileExt));
    }, 290);

    _setTimeout(function () {
      var _context3;

      factory.settings.features = path.join(__dirname, _concatInstanceProperty(_context3 = "".concat(mockFileName, ".")).call(_context3, mockFileExt));
    }, 590);

    _setTimeout(function () {
      var _context4;

      factory.settings.features = path.join(__dirname, _concatInstanceProperty(_context4 = "".concat(mockFileName, ".")).call(_context4, mockFileExt));
    }, 890);

    _setTimeout(function () {
      var _context5;

      factory.settings.features = path.join(__dirname, _concatInstanceProperty(_context5 = "update.".concat(mockFileName, ".")).call(_context5, mockFileExt));
    }, 1000);

    client.once(client.Event.SDK_UPDATE, function () {
      assert.equal(client.getTreatment('qa-user', 'testing_split_update'), 'updated_treatment', 'the update should be properly processed');
      assert["true"](_Date$now() - readyTimestamp > 1000);
      networkAssertions(client, assert).then(function () {
        client.destroy().then(assert.end);
      });
    });
  });
}

function ManagerDotSplitTests(assert) {
  configMocks();
  var config = settingsGenerator('.split');
  var factory = SplitFactory(config);
  var client = factory.client();
  var manager = factory.manager();
  manager.on(manager.Event.SDK_READY, function () {
    assert.deepEqual(manager.names(), ['testing_split', 'testing_split2', 'testing_split3']);
    var expectedView1 = {
      name: 'testing_split',
      changeNumber: 0,
      killed: false,
      trafficType: null,
      treatments: ['on'],
      configs: {}
    };
    var expectedView2 = {
      name: 'testing_split2',
      changeNumber: 0,
      killed: false,
      trafficType: null,
      treatments: ['off'],
      configs: {}
    };
    var expectedView3 = {
      name: 'testing_split3',
      changeNumber: 0,
      killed: false,
      trafficType: null,
      treatments: ['custom_treatment'],
      configs: {}
    };
    assert.deepEqual(manager.split('testing_split'), expectedView1);
    assert.deepEqual(manager.split('testing_split2'), expectedView2);
    assert.deepEqual(manager.split('testing_split3'), expectedView3);
    assert.equal(manager.split('split_not_existent'), null);
    assert.deepEqual(manager.splits(), [expectedView1, expectedView2, expectedView3]);
    networkAssertions(client, assert).then(function () {
      client.destroy().then(assert.end);
    });
  });
}

function ManagerDotYamlTests(mockFileName, assert) {
  configMocks();
  var config = settingsGenerator(mockFileName);
  var factory = SplitFactory(config);
  var client = factory.client();
  var manager = factory.manager();
  manager.on(manager.Event.SDK_READY, function () {
    assert.deepEqual(manager.names(), ['testing_split_on', 'testing_split_only_wl', 'testing_split_with_wl', 'testing_split_off_with_config']);
    var expectedView1 = {
      name: 'testing_split_on',
      changeNumber: 0,
      killed: false,
      trafficType: 'localhost',
      treatments: ['on'],
      configs: {}
    };
    var expectedView2 = {
      name: 'testing_split_only_wl',
      changeNumber: 0,
      killed: false,
      trafficType: 'localhost',
      treatments: ['whitelisted'],
      configs: {}
    };
    var expectedView3 = {
      name: 'testing_split_with_wl',
      changeNumber: 0,
      killed: false,
      trafficType: 'localhost',
      treatments: ['not_in_whitelist', 'one_key_wl', 'multi_key_wl'],
      configs: {
        not_in_whitelist: '{"color": "green"}',
        multi_key_wl: '{"color": "brown"}'
      }
    };
    var expectedView4 = {
      name: 'testing_split_off_with_config',
      changeNumber: 0,
      killed: false,
      trafficType: 'localhost',
      treatments: ['off'],
      configs: {
        off: '{"color": "green"}'
      }
    };
    assert.deepEqual(manager.split('testing_split_on'), expectedView1);
    assert.deepEqual(manager.split('testing_split_only_wl'), expectedView2);
    assert.deepEqual(manager.split('testing_split_with_wl'), expectedView3);
    assert.deepEqual(manager.split('testing_split_off_with_config'), expectedView4);
    assert.equal(manager.split('not_existent'), null);
    assert.deepEqual(manager.splits(), [expectedView1, expectedView2, expectedView3, expectedView4]);
    networkAssertions(client, assert).then(function () {
      client.destroy().then(assert.end);
    });
  });
}