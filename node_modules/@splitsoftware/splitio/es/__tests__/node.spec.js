import _regeneratorRuntime from "@babel/runtime-corejs3/regenerator";
import _bindInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/bind";
import _asyncToGenerator from "@babel/runtime-corejs3/helpers/esm/asyncToGenerator";
import tape from 'tape-catch';
import fetchMock from './utils/fetchMock';
import SettingsFactory from '../utils/settings';
import evaluationsSuite from './nodeSuites/evaluations.spec';
import eventsSuite from './nodeSuites/events.spec';
import impressionsSuite from './nodeSuites/impressions.spec';
import metricsSuite from './nodeSuites/metrics.spec';
import impressionsListenerSuite from './nodeSuites/impressions-listener.spec';
import expectedTreatmentsSuite from './nodeSuites/expected-treatments.spec';
import managerSuite from './nodeSuites/manager.spec';
import ipAddressesSetting from './nodeSuites/ip-addresses-setting.spec';
import splitChangesMock1 from './mocks/splitchanges.since.-1.json';
import splitChangesMock2 from './mocks/splitchanges.since.1457552620999.json';
var settings = SettingsFactory({
  core: {
    authorizationKey: '<fake-token>'
  }
});
var config = {
  core: {
    authorizationKey: '<fake-token-1>'
  },
  scheduler: {
    featuresRefreshRate: 1,
    segmentsRefreshRate: 1,
    metricsRefreshRate: 3000,
    // for now I don't want to publish metrics during E2E run.
    impressionsRefreshRate: 3000 // for now I don't want to publish impressions during E2E run.

  }
};
var key = 'facundo@split.io';
fetchMock.get(settings.url('/splitChanges?since=-1'), {
  status: 200,
  body: splitChangesMock1
});
fetchMock.get(settings.url('/splitChanges?since=1457552620999'), {
  status: 200,
  body: splitChangesMock2
});
fetchMock.get(new RegExp("".concat(settings.url('/segmentChanges'), "/*")), {
  status: 200,
  body: {
    'name': 'segment',
    'added': [],
    'removed': [],
    'since': 1,
    'till': 1
  }
});
fetchMock.post(settings.url('/testImpressions/bulk'), 200);
tape('## Node JS - E2E CI Tests ##', /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(assert) {
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            /* Check client evaluations. */
            assert.test('E2E / In Memory', _bindInstanceProperty(evaluationsSuite).call(evaluationsSuite, null, config, key));
            /* Check impressions */

            assert.test('E2E / Impressions', _bindInstanceProperty(impressionsSuite).call(impressionsSuite, null, key, fetchMock));
            assert.test('E2E / Impressions listener', impressionsListenerSuite);
            /* Check metrics */

            assert.test('E2E / Metrics', _bindInstanceProperty(metricsSuite).call(metricsSuite, null, key, fetchMock));
            /* Check events in memory */

            assert.test('E2E / Events', _bindInstanceProperty(eventsSuite).call(eventsSuite, null, fetchMock));
            /* Check that a treatment is the expected one for the key */

            assert.test('E2E / Expected Treatments by key', _bindInstanceProperty(expectedTreatmentsSuite).call(expectedTreatmentsSuite, null, config, settings, fetchMock));
            /* Manager basic tests */

            assert.test('E2E / Manager basics', _bindInstanceProperty(managerSuite).call(managerSuite, null, settings, fetchMock));
            /* Check IP address and Machine name headers when IP address setting is enabled and disabled */

            assert.test('E2E / IP Addresses Setting', _bindInstanceProperty(ipAddressesSetting).call(ipAddressesSetting, null, fetchMock));
            assert.end();

          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}());