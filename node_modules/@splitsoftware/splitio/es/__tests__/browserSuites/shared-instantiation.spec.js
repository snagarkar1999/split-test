import _asyncToGenerator from "@babel/runtime-corejs3/helpers/esm/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime-corejs3/regenerator";
import _bindInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/bind";
import { SplitFactory } from '../../';
import SettingsFactory from '../../utils/settings';
var settings = SettingsFactory({
  core: {
    key: 'asd'
  }
});
export default function (startWithTT, fetchMock, assert) {
  var _context, _context2, _context3, _context4;

  var factory = SplitFactory({
    core: {
      authorizationKey: 'dummy',
      key: 'facundo@split.io',
      trafficType: startWithTT ? 'start_tt' : undefined
    },
    startup: {
      eventsFirstPushWindow: 3
    }
  });
  var mainClient = factory.client();
  assert.equal(mainClient, factory.client(), 'If we call factory.client() (no params) more than once, it is just a get of the main client.');
  assert.equal(mainClient, factory.client('facundo@split.io', startWithTT ? 'start_tt' : undefined), 'If we call factory.client() with params matching what was passed on the configuration, it is just a get of the main client still.');
  var nicolasClient = factory.client('nicolas@split.io', 'nico_tt');
  var marcioClient = factory.client('marcio@split.io');
  assert["throws"](_bindInstanceProperty(_context = factory.client).call(_context, factory, null), 'Calling factory.client() with a key parameter that is not a valid key should throw.');
  assert["throws"](_bindInstanceProperty(_context2 = factory.client).call(_context2, factory, {}), 'Calling factory.client() with a key parameter that is not a valid key should throw.');
  assert["throws"](_bindInstanceProperty(_context3 = factory.client).call(_context3, factory, 'validKey', null), 'Calling factory.client() with a traffic type parameter that is not a valid should throw.');
  assert["throws"](_bindInstanceProperty(_context4 = factory.client).call(_context4, factory, 'validKey', []), 'Calling factory.client() with a traffic type parameter that is not a valid should throw.'); // Used for wrapping up test when we should

  var finished = /*#__PURE__*/_regeneratorRuntime.mark(function f() {
    return _regeneratorRuntime.wrap(function f$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return;

          case 2:
            _context5.next = 4;
            return;

          case 4:
            _context5.next = 6;
            return;

          case 6:
            marcioClient.destroy();
            nicolasClient.destroy();
            mainClient.destroy();
            assert.end();

          case 10:
          case "end":
            return _context5.stop();
        }
      }
    }, f);
  })();
  /**
   * Assertion suite for client.getTreatment() & client.getTreatments()
   */


  var getTreatmentsAssertions = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(client, expect) {
      return _regeneratorRuntime.wrap(function _callee$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _context6.t0 = assert;
              _context6.next = 3;
              return client.getTreatment('always_off');

            case 3:
              _context6.t1 = _context6.sent;
              _context6.t2 = expect[0];

              _context6.t0.equal.call(_context6.t0, _context6.t1, _context6.t2, 'Shared client evaluations should be correct.');

              _context6.t3 = assert;
              _context6.next = 9;
              return client.getTreatment('always_on');

            case 9:
              _context6.t4 = _context6.sent;
              _context6.t5 = expect[1];

              _context6.t3.equal.call(_context6.t3, _context6.t4, _context6.t5, 'Shared client evaluations should be correct.');

              _context6.t6 = assert;
              _context6.next = 15;
              return client.getTreatment('splitters');

            case 15:
              _context6.t7 = _context6.sent;
              _context6.t8 = expect[2];

              _context6.t6.equal.call(_context6.t6, _context6.t7, _context6.t8, 'Shared client evaluations should be correct.');

              _context6.t9 = assert;
              _context6.next = 21;
              return client.getTreatment('developers');

            case 21:
              _context6.t10 = _context6.sent;
              _context6.t11 = expect[3];

              _context6.t9.equal.call(_context6.t9, _context6.t10, _context6.t11, 'Shared client evaluations should be correct.');

              _context6.t12 = assert;
              _context6.next = 27;
              return client.getTreatment('not_exists');

            case 27:
              _context6.t13 = _context6.sent;

              _context6.t12.equal.call(_context6.t12, _context6.t13, 'control', 'Shared client evaluations should be correct.');

              _context6.t14 = assert;
              _context6.next = 32;
              return client.getTreatments(['always_off', 'always_on', 'splitters', 'developers', 'not_exists']);

            case 32:
              _context6.t15 = _context6.sent;
              _context6.t16 = {
                'always_off': expect[0],
                'always_on': expect[1],
                'splitters': expect[2],
                'developers': expect[3],
                'not_exists': 'control'
              };

              _context6.t14.deepEqual.call(_context6.t14, _context6.t15, _context6.t16, 'Shared client evaluations should be correct.');

              finished.next();

            case 36:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee);
    }));

    return function getTreatmentsAssertions(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
  /**
   * Assertion suite for client.track()
   */


  var trackAssertions = function trackAssertions() {
    // Prepare the mock to check for events having correct values
    fetchMock.postOnce(settings.url('/events/bulk'), function (url, opts) {
      var events = JSON.parse(opts.body);
      assert.equal(events.length, 3, 'Tracked only valid events');
      assert.equal(events[0].trafficTypeName, "".concat(startWithTT ? 'start' : 'main', "_tt"), 'matching traffic types both binded and provided through client.track()');
      assert.equal(events[1].trafficTypeName, 'nico_tt', 'matching traffic types both binded and provided through client.track()');
      assert.equal(events[2].trafficTypeName, 'marcio_tt', 'matching traffic types both binded and provided through client.track()');
      finished.next();
      return 200;
    });

    if (startWithTT) {
      assert["true"](mainClient.track('myEvent', 10), 'If we specified the TT via settings, we should be able to track events without passing it as param');
    } else {
      assert["false"](mainClient.track('myEvent'), 'If we have not specified TT via settings, it should be required on client.track()');
      assert["true"](mainClient.track('main_tt', 'myEvent', 10), 'If we have not specified TT via settings, it should be required on client.track()');
    } // Shared instance with TT on instantiation


    assert["true"](nicolasClient.track('nicoEvent', 10), 'If a shared client was created passing both key and TT, the latter gets binded to it so it is not necessary to provide the traffic type to client.track()'); // Shared instance without TT on instantiation

    assert["false"](marcioClient.track('marcioEvent'), 'If a shared client was created passing only key, no traffic type is binded so we need to provide one for client.track()');
    assert["true"](marcioClient.track('marcio_tt', 'marcioEvent', 10), 'If a shared client was created passing only key, no traffic type is binded so we need to provide one for client.track()');
  };
  /* Assert initial state */


  assert.equal(mainClient.ready, nicolasClient.ready, 'Shared clients should share the ready flag.');
  assert.equal(mainClient.ready, marcioClient.ready, 'Shared clients should share the ready flag.');
  assert.equal(nicolasClient.ready, marcioClient.ready, 'Shared clients should share the ready flag.');
  /* Assert client.track(), no need to wait for ready. */

  trackAssertions();
  /* Assert getTreatment/s */

  var expectControls = ['control', 'control', 'control', 'control']; // If main is not ready and returning controls, they all return controls.

  getTreatmentsAssertions(mainClient, expectControls);
  getTreatmentsAssertions(nicolasClient, expectControls);
  getTreatmentsAssertions(marcioClient, expectControls); // Once main is ready, they all should be ready. Same thing to use one ready or the other.

  nicolasClient.ready().then(function () {
    assert.comment('Main instance - facundo@split.io');
    getTreatmentsAssertions(mainClient, ['off', 'on', 'on', 'off']);
  });
  mainClient.ready().then(function () {
    assert.comment('Shared instance - nicolas@split.io');
    getTreatmentsAssertions(nicolasClient, ['off', 'on', 'off', 'on']);
  });
  marcioClient.ready().then(function () {
    assert.comment('Shared instance - marcio@split.io');
    getTreatmentsAssertions(marcioClient, ['off', 'on', 'off', 'off']);
  });
}