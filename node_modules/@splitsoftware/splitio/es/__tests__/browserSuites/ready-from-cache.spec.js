import _Object$defineProperty from "@babel/runtime-corejs3/core-js-stable/object/define-property";
import _Object$defineProperties from "@babel/runtime-corejs3/core-js-stable/object/define-properties";
import _Object$getOwnPropertyDescriptors from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _Object$getOwnPropertyDescriptor from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor";
import _filterInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/filter";
import _Object$getOwnPropertySymbols from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols";
import _Object$keys from "@babel/runtime-corejs3/core-js-stable/object/keys";
import _Date$now from "@babel/runtime-corejs3/core-js-stable/date/now";
import _setTimeout from "@babel/runtime-corejs3/core-js-stable/set-timeout";
import _Promise from "@babel/runtime-corejs3/core-js-stable/promise";
import _defineProperty from "@babel/runtime-corejs3/helpers/esm/defineProperty";
import _JSON$stringify from "@babel/runtime-corejs3/core-js-stable/json/stringify";

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context; _forEachInstanceProperty(_context = ownKeys(Object(source), true)).call(_context, function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { var _context2; _forEachInstanceProperty(_context2 = ownKeys(Object(source))).call(_context2, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { SplitFactory } from '../../';
import splitChangesMock1 from '../mocks/splitchanges.since.-1.json';
import splitChangesMock2 from '../mocks/splitchanges.since.1457552620999.json';
import mySegmentsNicolas from '../mocks/mysegments.nicolas@split.io.json';

var alwaysOnSplitInverted = _JSON$stringify({
  'environment': null,
  'trafficTypeId': null,
  'trafficTypeName': null,
  'name': 'always_on',
  'seed': -790401604,
  'status': 'ACTIVE',
  'killed': false,
  'defaultTreatment': 'off',
  'conditions': [{
    'matcherGroup': {
      'combiner': 'AND',
      'matchers': [{
        'keySelector': {
          'trafficType': 'user',
          'attribute': null
        },
        'matcherType': 'ALL_KEYS',
        'negate': false,
        'userDefinedSegmentMatcherData': null,
        'whitelistMatcherData': null,
        'unaryNumericMatcherData': null,
        'betweenMatcherData': null
      }]
    },
    'partitions': [{
      'treatment': 'off',
      'size': 100
    }]
  }]
});

var baseConfig = {
  core: {
    authorizationKey: '<fake-token-rfc>',
    key: 'nicolas@split.io'
  },
  scheduler: {
    featuresRefreshRate: 3000,
    segmentsRefreshRate: 3000,
    metricsRefreshRate: 3000,
    impressionsRefreshRate: 3000
  },
  startup: {
    readyTimeout: 10,
    requestTimeoutBeforeReady: 10,
    eventsFirstPushWindow: 3000
  }
};
export default function (fetchMock, assert) {
  assert.test(function (t) {
    // Testing when we start from scratch
    var testUrls = {
      sdk: 'https://sdk.baseurl/readyFromCacheEmpty',
      events: 'https://events.baseurl/readyFromCacheEmpty'
    };
    localStorage.clear();
    t.plan(3);
    fetchMock.get(testUrls.sdk + '/splitChanges?since=-1', {
      status: 200,
      body: splitChangesMock1
    });
    fetchMock.get(testUrls.sdk + '/splitChanges?since=1457552620999', {
      status: 200,
      body: splitChangesMock2
    });
    fetchMock.get(testUrls.sdk + '/mySegments/nicolas@split.io', {
      status: 200,
      body: mySegmentsNicolas
    });
    fetchMock.get(testUrls.sdk + '/mySegments/nicolas2@split.io', {
      status: 200,
      body: {
        'mySegments': []
      }
    });
    fetchMock.get(testUrls.sdk + '/mySegments/nicolas3@split.io', {
      status: 200,
      body: {
        'mySegments': []
      }
    });
    var splitio = SplitFactory(_objectSpread({}, baseConfig, {
      core: _objectSpread({}, baseConfig.core, {
        authorizationKey: '<fake-token-rfc2>'
      }),
      storage: {
        type: 'LOCALSTORAGE',
        prefix: 'readyFromCache_1'
      },
      urls: testUrls
    }));
    var client = splitio.client();
    var client2 = splitio.client('nicolas2@split.io');
    var client3 = splitio.client('nicolas3@split.io');
    client.once(client.Event.SDK_READY_TIMED_OUT, function () {
      t.fail('It should not timeout in this scenario.');
      t.end();
    });
    client.once(client.Event.SDK_READY_FROM_CACHE, function () {
      t.fail('It should not emit SDK_READY_FROM_CACHE if there is no cache.');
      t.end();
    });
    client.on(client.Event.SDK_READY, function () {
      t.pass('It should emit SDK_READY alone, since there was no cache.');
    });
    client2.on(client.Event.SDK_READY, function () {
      t.pass('It should emit SDK_READY alone, since there was no cache.');
    });
    client3.on(client.Event.SDK_READY, function () {
      t.pass('It should emit SDK_READY alone, since there was no cache.');
    });
  });
  assert.test(function (t) {
    var testUrls = {
      sdk: 'https://sdk.baseurl/readyFromCacheWithData',
      events: 'https://events.baseurl/readyFromCacheWithData'
    };
    localStorage.clear();
    t.plan(6 * 2);
    fetchMock.get(testUrls.sdk + '/splitChanges?since=25', function () {
      return new _Promise(function (res) {
        _setTimeout(function () {
          return res({
            status: 200,
            body: _objectSpread({}, splitChangesMock1, {
              since: 25
            }),
            headers: {}
          });
        }, 200);
      }); // 400ms is how long it'll take to reply with Splits, no SDK_READY should be emitted before that.
    });
    fetchMock.get(testUrls.sdk + '/splitChanges?since=1457552620999', {
      status: 200,
      body: splitChangesMock2
    });
    fetchMock.get(testUrls.sdk + '/mySegments/nicolas@split.io', function () {
      return new _Promise(function (res) {
        _setTimeout(function () {
          return res({
            status: 200,
            body: mySegmentsNicolas,
            headers: {}
          });
        }, 400);
      }); // First client gets segments before splits. No segment cache loading (yet)
    });
    fetchMock.get(testUrls.sdk + '/mySegments/nicolas2@split.io', function () {
      return new _Promise(function (res) {
        _setTimeout(function () {
          return res({
            status: 200,
            body: {
              'mySegments': []
            },
            headers: {}
          });
        }, 700);
      }); // Second client gets segments after 700ms
    });
    fetchMock.get(testUrls.sdk + '/mySegments/nicolas3@split.io', function () {
      return new _Promise(function (res) {
        _setTimeout(function () {
          return res({
            status: 200,
            body: {
              'mySegments': []
            },
            headers: {}
          });
        }, 1000);
      }); // Third client mySegments will come after 1s
    });
    fetchMock.postOnce(testUrls.events + '/testImpressions/bulk', 200);
    localStorage.setItem('readyFromCache_2.SPLITIO.splits.till', 25);
    localStorage.setItem('readyFromCache_2.SPLITIO.split.always_on', alwaysOnSplitInverted);

    var startTime = _Date$now();

    var splitio = SplitFactory(_objectSpread({}, baseConfig, {
      storage: {
        type: 'LOCALSTORAGE',
        prefix: 'readyFromCache_2'
      },
      urls: testUrls,
      debug: true
    }));
    var client = splitio.client();
    var client2 = splitio.client('nicolas2@split.io');
    var client3 = splitio.client('nicolas3@split.io');
    client.once(client.Event.SDK_READY_TIMED_OUT, function () {
      t.fail('It should not timeout in this scenario.');
      t.end();
    });
    client.once(client.Event.SDK_READY_FROM_CACHE, function () {
      t["true"](_Date$now() - startTime < 400, 'It should emit SDK_READY_FROM_CACHE on every client if there was data in the cache and we subscribe on time. Should be considerably faster than actual readiness from the cloud.');
      t.equal(client.getTreatment('always_on'), 'off', 'It should evaluate treatments with data from cache instead of control due to Input Validation');
    });
    client2.once(client.Event.SDK_READY_FROM_CACHE, function () {
      t["true"](_Date$now() - startTime < 400, 'It should emit SDK_READY_FROM_CACHE on every client if there was data in the cache and we subscribe on time. Should be considerably faster than actual readiness from the cloud.');
      t.equal(client.getTreatment('always_on'), 'off', 'It should evaluate treatments with data from cache instead of control due to Input Validation');
    });
    client3.once(client.Event.SDK_READY_FROM_CACHE, function () {
      t["true"](_Date$now() - startTime < 400, 'It should emit SDK_READY_FROM_CACHE on every client if there was data in the cache and we subscribe on time. Should be considerably faster than actual readiness from the cloud.');
      t.equal(client.getTreatment('always_on'), 'off', 'It should evaluate treatments with data from cache instead of control due to Input Validation');
    });
    client.on(client.Event.SDK_READY, function () {
      t["true"](_Date$now() - startTime >= 400, 'It should emit SDK_READY too but after syncing with the cloud.');
      t.equal(client.getTreatment('always_on'), 'on', 'It should evaluate treatments with updated data after syncing with the cloud.');
    });
    client2.on(client.Event.SDK_READY, function () {
      t["true"](_Date$now() - startTime >= 700, 'It should emit SDK_READY too but after syncing with the cloud.');
      t.equal(client.getTreatment('always_on'), 'on', 'It should evaluate treatments with updated data after syncing with the cloud.');
    });
    client3.on(client.Event.SDK_READY, function () {
      t["true"](_Date$now() - startTime >= 1000, 'It should emit SDK_READY too but after syncing with the cloud.');
      t.equal(client.getTreatment('always_on'), 'on', 'It should evaluate treatments with updated data after syncing with the cloud.');
    });
  });
}