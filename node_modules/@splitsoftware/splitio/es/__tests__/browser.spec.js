import _bindInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/bind";
import tape from 'tape-catch';
import fetchMock from './utils/fetchMock';
import evaluationsSuite from './browserSuites/evaluations.spec';
import impressionsSuite from './browserSuites/impressions.spec';
import metricsSuite from './browserSuites/metrics.spec';
import impressionsListenerSuite from './browserSuites/impressions-listener.spec';
import readinessSuite from './browserSuites/readiness.spec';
import readyFromCache from './browserSuites/ready-from-cache.spec';
import { withoutBindingTT, bindingTT } from './browserSuites/events.spec';
import sharedInstantiationSuite from './browserSuites/shared-instantiation.spec';
import managerSuite from './browserSuites/manager.spec';
import ignoreIpAddressesSettingSuite from './browserSuites/ignore-ip-addresses-setting.spec';
import useBeaconApiSuite from './browserSuites/use-beacon-api.spec';
import SettingsFactory from '../utils/settings';
import splitChangesMock1 from './mocks/splitchanges.since.-1.json';
import splitChangesMock2 from './mocks/splitchanges.since.1457552620999.json';
import mySegmentsFacundo from './mocks/mysegments.facundo@split.io.json';
import mySegmentsNicolas from './mocks/mysegments.nicolas@split.io.json';
import mySegmentsMarcio from './mocks/mysegments.marcio@split.io.json';
var settings = SettingsFactory({
  core: {
    key: 'facundo@split.io'
  }
});
var configInMemory = {
  core: {
    authorizationKey: '<fake-token>',
    key: 'facundo@split.io'
  },
  scheduler: {
    featuresRefreshRate: 1,
    segmentsRefreshRate: 1,
    metricsRefreshRate: 3000,
    // for now I don't want to publish metrics during E2E run.
    impressionsRefreshRate: 3000 // for now I don't want to publish impressions during E2E run.

  }
};
var configInMemoryWithBucketingKey = {
  core: {
    authorizationKey: '<fake-token>',
    key: {
      matchingKey: 'facundo@split.io',
      bucketingKey: 'some_id'
    }
  },
  scheduler: {
    featuresRefreshRate: 1,
    segmentsRefreshRate: 1,
    metricsRefreshRate: 3000,
    // for now I don't want to publish metrics during E2E run.
    impressionsRefreshRate: 3000 // for now I don't want to publish impressions during E2E run.

  }
};
var configInLocalStorage = {
  core: {
    authorizationKey: '<fake-token>',
    key: 'facundo@split.io'
  },
  scheduler: {
    featuresRefreshRate: 1,
    segmentsRefreshRate: 1,
    metricsRefreshRate: 3000,
    // for now I don't want to publish metrics during E2E run.
    impressionsRefreshRate: 3000 // for now I don't want to publish impressions during E2E run.

  },
  storage: {
    type: 'LOCALSTORAGE',
    prefix: 'e2eTEST' // Avoid storage name clashes

  }
};
tape('## E2E CI Tests ##', function (assert) {
  //If we change the mocks, we need to clear localstorage. Cleaning up after testing ensures "fresh data".
  localStorage.clear();
  fetchMock.get(settings.url('/splitChanges?since=-1'), {
    status: 200,
    body: splitChangesMock1
  });
  fetchMock.get(settings.url('/splitChanges?since=1457552620999'), {
    status: 200,
    body: splitChangesMock2
  });
  fetchMock.get(settings.url('/mySegments/facundo@split.io'), {
    status: 200,
    body: mySegmentsFacundo
  });
  fetchMock.get(settings.url('/mySegments/nicolas@split.io'), {
    status: 200,
    body: mySegmentsNicolas
  });
  fetchMock.get(settings.url('/mySegments/marcio@split.io'), {
    status: 200,
    body: mySegmentsMarcio
  });
  fetchMock.post(settings.url('/testImpressions/bulk'), 200);
  /* Check client evaluations. */

  assert.test('E2E / In Memory', _bindInstanceProperty(evaluationsSuite).call(evaluationsSuite, null, configInMemory, fetchMock));
  assert.test('E2E / In Memory with Bucketing Key', _bindInstanceProperty(evaluationsSuite).call(evaluationsSuite, null, configInMemoryWithBucketingKey, fetchMock));
  assert.test('E2E / In LocalStorage with In Memory Fallback', _bindInstanceProperty(evaluationsSuite).call(evaluationsSuite, null, configInLocalStorage, fetchMock));
  /* Check impressions */

  assert.test('E2E / Impressions', _bindInstanceProperty(impressionsSuite).call(impressionsSuite, null, fetchMock));
  /* Check impression listener */

  assert.test('E2E / Impression listener', impressionsListenerSuite);
  /* Check metrics */

  assert.test('E2E / Metrics', _bindInstanceProperty(metricsSuite).call(metricsSuite, null, fetchMock));
  /* Check events */

  assert.test('E2E / Events', _bindInstanceProperty(withoutBindingTT).call(withoutBindingTT, null, fetchMock));
  assert.test('E2E / Events with TT binded', _bindInstanceProperty(bindingTT).call(bindingTT, null, fetchMock));
  /* Check shared clients */

  assert.test('E2E / Shared instances', _bindInstanceProperty(sharedInstantiationSuite).call(sharedInstantiationSuite, null, false, fetchMock));
  assert.test('E2E / Shared instances with Traffic Type on factory settings', _bindInstanceProperty(sharedInstantiationSuite).call(sharedInstantiationSuite, null, true, fetchMock));
  /* Check basic manager functionality */

  assert.test('E2E / Manager API', _bindInstanceProperty(managerSuite).call(managerSuite, null, settings, fetchMock));
  /* Validate readiness */

  assert.test('E2E / Readiness', _bindInstanceProperty(readinessSuite).call(readinessSuite, null, fetchMock));
  /* Validate headers for ip and hostname are not sended with requests (ignore setting IPAddressesEnabled) */

  assert.test('E2E / Ignore setting IPAddressesEnabled', _bindInstanceProperty(ignoreIpAddressesSettingSuite).call(ignoreIpAddressesSettingSuite, null, fetchMock));
  /* Check that impressions and events are sended to backend via Beacon API or Fetch when page unload is triggered. */

  assert.test('E2E / Use Beacon API (or Fetch if not available) to send remaining impressions and events when browser page is unload', _bindInstanceProperty(useBeaconApiSuite).call(useBeaconApiSuite, null, fetchMock));
  /* Validate ready from cache behaviour (might be merged into another suite if we end up having simple behavior around it as expected) */

  assert.test('E2E / Readiness from cache', _bindInstanceProperty(readyFromCache).call(readyFromCache, null, fetchMock)); //If we change the mocks, we need to clear localstorage. Cleaning up after testing ensures "fresh data".

  localStorage.clear();
  assert.end();
});