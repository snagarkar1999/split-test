import _Object$defineProperty from "@babel/runtime-corejs3/core-js-stable/object/define-property";
import _Object$defineProperties from "@babel/runtime-corejs3/core-js-stable/object/define-properties";
import _Object$getOwnPropertyDescriptors from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors";
import _Object$getOwnPropertyDescriptor from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor";
import _filterInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/filter";
import _Object$getOwnPropertySymbols from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols";
import _defineProperty from "@babel/runtime-corejs3/helpers/esm/defineProperty";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _Map from "@babel/runtime-corejs3/core-js-stable/map";
import _Symbol from "@babel/runtime-corejs3/core-js-stable/symbol";
import _Promise from "@babel/runtime-corejs3/core-js-stable/promise";
import _Number$isFinite from "@babel/runtime-corejs3/core-js-stable/number/is-finite";
import _reduceInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/reduce";
import _Object$keys from "@babel/runtime-corejs3/core-js-stable/object/keys";

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context2; _forEachInstanceProperty(_context2 = ownKeys(Object(source), true)).call(_context2, function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { var _context3; _forEachInstanceProperty(_context3 = ownKeys(Object(source))).call(_context3, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

import tape from 'tape-catch';
import sinon from 'sinon';
import proxyquire from 'proxyquire';
var proxyquireStrict = proxyquire.noCallThru();
var loggerMock = {
  warn: sinon.stub(),
  error: sinon.stub()
};

function LogFactoryMock() {
  return loggerMock;
}

var _proxyquireStrict = proxyquireStrict('../../inputValidation/eventProperties', {
  '../logger': LogFactoryMock
}),
    validateEventProperties = _proxyquireStrict.validateEventProperties;
/* We'll reset the history for the next test */


function resetStubs() {
  loggerMock.warn.resetHistory();
  loggerMock.error.resetHistory();
}

function calculateSize(obj) {
  // we calculate the expected size.
  var keys = _Object$keys(obj); // each string char counts as two bytes.


  var keysSize = _reduceInstanceProperty(keys).call(keys, function (accum, key) {
    return accum + key.length * 2;
  }, 0);

  var valuesSize = _reduceInstanceProperty(keys).call(keys, function (accum, key) {
    if (obj[key] === null) return accum; // 0 for null

    if (_Number$isFinite(obj[key])) return accum + 8; // 8 for numbers

    if (obj[key] === true || obj[key] === false) return accum + 4; // 4 for bool

    if (typeof obj[key] === 'string') return accum + obj[key].length * 2;
    return accum; // Invalid props won't count towards the size, since those should had been
  }, 0);

  return keysSize + valuesSize;
}

var invalidValues = [[], function () {}, false, true, 'something', NaN, -Infinity, Infinity, new _Promise(function (res) {
  return res;
}), _Symbol('asd'), new _Map()];
tape('INPUT VALIDATION for Event Properties', function (t) {
  t.test('Not setting the properties object is acceptable', function (assert) {
    assert.deepEqual(validateEventProperties(undefined, 'some_method_eventProps'), {
      properties: null,
      size: 1024
    }, 'It should return null in replacement of undefined since it is valid with default event size.');
    assert.deepEqual(validateEventProperties(undefined, 'some_method_eventProps'), {
      properties: null,
      size: 1024
    }, 'It should return the passed null since it is valid with default event size.');
    assert.notOk(loggerMock.error.called, 'Should not log any errors.');
    assert.notOk(loggerMock.warn.called, 'It should have not logged any warnings.');
    resetStubs();
    assert.end();
  });
  t.test('When setting a value for properties, only objects are acceptable', function (assert) {
    _forEachInstanceProperty(invalidValues).call(invalidValues, function (val) {
      assert.deepEqual(validateEventProperties(val, 'some_method_eventProps'), {
        properties: false,
        size: 1024
      }, 'It should return default size and properties false if the properties value is not an object or null/undefined.');
      assert.ok(loggerMock.error.calledOnceWithExactly('some_method_eventProps: properties must be a plain object.'), 'Should log an error.');
      loggerMock.error.resetHistory();
    });

    assert.notOk(loggerMock.warn.called, 'It should have not logged any warnings.');
    resetStubs();
    assert.end();
  });
  t.test('It should return the properties object when valid and also the correct event size', function (assert) {
    // The events are considered to weight 1024 bytes (1kb) in average without props. Properties add to that.
    var validProperties = {
      bool: true,
      falseyBool: false,
      string: 'a string',
      number: 123,
      number2: 0.250,
      nullProp: null
    };
    var output = validateEventProperties(validProperties, 'some_method_eventProps');
    assert.deepEqual(output, {
      properties: validProperties,
      size: 1024 + calculateSize(validProperties)
    }, 'It should return the properties and the event size.');
    assert.notEqual(validProperties, output.properties, 'Returned properties should be a clone.');
    assert.notOk(loggerMock.error.called, 'Should not log any errors.');
    assert.notOk(loggerMock.warn.called, 'It should have not logged any warnings.');
    resetStubs();
    assert.end();
  });
  t.test('It should return the properties object when valid and also the correct event size, nulling any invalid prop', function (assert) {
    var _context;

    // The events are considered to weight 1024 bytes (1kb) in average without props. Properties add to that.
    var providedProperties = {
      bool: true,
      falseyBool: false,
      string: 'a string',
      number: 123,
      nullProp: null,
      willBeNulled1: function willBeNulled1() {},
      willBeNulled2: {},
      willBeNulled3: [],
      willBeNulled4: new _Map()
    };
    var output = validateEventProperties(providedProperties, 'some_method_eventProps');
    assert.deepEqual(output, {
      properties: _objectSpread({}, providedProperties, {
        willBeNulled1: null,
        willBeNulled2: null,
        willBeNulled3: null,
        willBeNulled4: null
      }),
      size: 1024 + calculateSize(providedProperties)
    }, 'It should return the properties and the event size.');
    assert.notEqual(providedProperties, output.properties, 'Returned properties should be a clone.');
    assert.notOk(loggerMock.error.called, 'Should not log any errors.');
    assert.equal(loggerMock.warn.callCount, 4, 'It should have logged one warning per each property of the invalid type.');

    _forEachInstanceProperty(_context = ['willBeNulled1', 'willBeNulled2', 'willBeNulled3', 'willBeNulled4']).call(_context, function (key) {
      assert.ok(loggerMock.warn.calledWithExactly("some_method_eventProps: Property ".concat(key, " is of invalid type. Setting value to null.")));
    });

    resetStubs();
    assert.end();
  });
  t.test('It should log a warning if the object has more than the max amount of allowed keys, logging a warning and returning the event (if other validations pass)', function (assert) {
    var validProperties = {};

    for (var i = 0; i < 300; i++) {
      validProperties[i] = null; // all will be null so we do not exceed the size.
    }

    var output = validateEventProperties(validProperties, 'some_method_eventProps');
    assert.deepEqual(output, {
      properties: validProperties,
      size: 1024 + calculateSize(validProperties)
    }, 'It should return the properties and the event size.');
    assert.notOk(loggerMock.error.called, 'Should not log any errors.');
    assert.notOk(loggerMock.warn.called, 'It should have not logged any warnings.');
    validProperties.a = null; // Adding one prop to exceed the limit.

    output = validateEventProperties(validProperties, 'some_method_eventProps');
    assert.deepEqual(output, {
      properties: validProperties,
      size: 1024 + calculateSize(validProperties)
    }, 'It should return the properties and the event size.');
    assert.notOk(loggerMock.error.called, 'Should not log any errors.');
    assert.ok(loggerMock.warn.calledOnceWithExactly('some_method_eventProps: Event has more than 300 properties. Some of them will be trimmed when processed.'), 'It should have not logged any warnings.');
    resetStubs();
    assert.end();
  });
  var fiveHundredChars = 'JKHSAKFJASHFJKASHSFKHAKJSGJKASGH1234567890JASHGJHASGJKAHSJKGHAJKSHGJKAHGJKASHajksghkjahsgjkhsakjghjkashgjkhagjkhajksghjkahsgjksahgjkahsgjkhasgjkhsagjkabsgjhaenjkrnjkwnqrkjnqwekjrnkjweqntkjnjkenasdjkngjksdajkghkjdasgkjnadsjgn asdkjgnkjsadngkjnasdjkngjknasdkjgnasdlgnsdakgnlkasndugbuoewqoitnwlkgadsgjdnsagubadisugboisdngklasdgndsgbjasdbgjkasbdgubuiqwetoiqhweiojtioweqhtiohqweiohtiowqehtoihewqiobtgoiqwengiowqnegionwqeogiqwneoignqiowegnioqewgnwqoiegnoiqwengiowqnegoinqwgionqwegionwqeoignqwegoinoiadnfaosignoiansgk';
  t.test('It should log an error and not return the properties if it exceeds the 32kb size limit', function (assert) {
    var validProperties = {};

    for (var i = 10; i < 41; i++) {
      validProperties[i] = fiveHundredChars; // key length is two, plus 510 chars it is 512 which multiplied by the byte size of each char is 1kb each key.
    } // It should be right on the size limit.


    var output = validateEventProperties(validProperties, 'some_method_eventProps');
    assert.deepEqual(output, {
      properties: validProperties,
      size: 1024 + calculateSize(validProperties)
    }, 'It should return the properties and the event size.');
    assert.notEqual(validProperties, output.properties, 'Returned properties should be a clone.');
    assert.notOk(loggerMock.error.called, 'Should not log any errors.');
    assert.notOk(loggerMock.warn.called, 'Should not log any warnings.');
    validProperties.a = null; // exceed by two bytes (1 char string key which is two bytes, null value which we count as 0 to match other SDKs)

    output = validateEventProperties(validProperties, 'some_method_eventProps');
    assert.deepEqual(output, {
      properties: false,
      size: 1024 * 32 + 2 // the two extra bytes.

    }, 'It should return false instead of the properties and the event size.');
    assert.notOk(loggerMock.warn.called, 'Should not log any warnings.');
    assert.ok(loggerMock.error.calledOnceWithExactly('some_method_eventProps: The maximum size allowed for the properties is 32768 bytes, which was exceeded. Event not queued.'), 'Should not log any errors.');
    loggerMock.error.resetHistory();
    resetStubs();
    assert.end();
  });
});