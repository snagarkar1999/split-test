import _indexOfInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/index-of";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";
import _typeof from "@babel/runtime-corejs3/helpers/esm/typeof";
import tape from 'tape-catch';
import sinon from 'sinon';
/* eslint-disable no-console */

import { Logger, LogLevels, setLogLevel } from '../../logger/LoggerFactory';
import { LOG_LEVELS } from './index.spec.js';
tape('SPLIT LOGGER FACTORY / setLogLevel utility function', function (assert) {
  assert.equal(_typeof(setLogLevel), 'function', 'setLogLevel should be a function');
  assert.doesNotThrow(setLogLevel, 'Calling setLogLevel should not throw an error.');
  assert.end();
});
tape('SPLIT LOGGER FACTORY / LogLevels exposed mappings', function (assert) {
  assert.deepEqual(LogLevels, LOG_LEVELS, 'Exposed log levels should contain the levels we want.');
  assert.end();
});
tape('SPLIT LOGGER FACTORY / Logger class shape', function (assert) {
  assert.equal(_typeof(Logger), 'function', 'Logger should be a class we can instantiate.');
  var logger = new Logger('test-category', {});
  assert.equal(_typeof(logger.debug), 'function', 'instance.debug should be a method.');
  assert.equal(_typeof(logger.info), 'function', 'instance.info should be a method.');
  assert.equal(_typeof(logger.warn), 'function', 'instance.warn should be a method.');
  assert.equal(_typeof(logger.error), 'function', 'instance.error should be a method.');
  assert.end();
});
var LOG_LEVELS_IN_ORDER = ['DEBUG', 'INFO', 'WARN', 'ERROR', 'NONE'];
/* Utility function to avoid repeating too much code */

function testLogLevels(levelToTest, assert) {
  // Builds the expected message.
  var buildExpectedMessage = function buildExpectedMessage(lvl, category, msg, showLevel) {
    var res = '';
    if (showLevel) res += '[' + lvl + ']' + (lvl.length === 4 ? '  ' : ' ');
    res += category + ' => ';
    res += msg;
    return res;
  }; // Runs the suite with the given value for showLevel option.


  var runTests = function runTests(showLevel, displayAllErrors) {
    var _context;

    var logLevelLogsCounter = 0;
    var testForNoLog = false;
    var logMethod = levelToTest.toLowerCase();

    var logCategory = _concatInstanceProperty(_context = "test-category-".concat(logMethod)).call(_context, displayAllErrors ? 'displayAllErrors' : '');

    var instance = new Logger(logCategory, {
      showLevel: showLevel,
      displayAllErrors: displayAllErrors
    });

    _forEachInstanceProperty(LOG_LEVELS_IN_ORDER).call(LOG_LEVELS_IN_ORDER, function (logLevel, i) {
      var _context2, _context3, _context4, _context5, _context6, _context7;

      var logMsg = _concatInstanceProperty(_context2 = _concatInstanceProperty(_context3 = _concatInstanceProperty(_context4 = "Test log for level ".concat(levelToTest, " (")).call(_context4, displayAllErrors ? 'But all errors are configured to display' : 'Errors not forced to display', ") with showLevel: ")).call(_context3, showLevel, " ")).call(_context2, logLevelLogsCounter);

      var expectedMessage = buildExpectedMessage(levelToTest, logCategory, logMsg, showLevel); // Log error should always be visible.

      if (logMethod === LOG_LEVELS.ERROR.toLowerCase() && displayAllErrors) testForNoLog = false; // Set the logLevel for this iteration.

      setLogLevel(LogLevels[logLevel]); // Call the method

      instance[logMethod](logMsg); // Assert if console.log was called.

      assert[testForNoLog ? 'notOk' : 'ok'](console.log.calledWith(expectedMessage), _concatInstanceProperty(_context5 = _concatInstanceProperty(_context6 = _concatInstanceProperty(_context7 = "Calling ".concat(logMethod, " method should ")).call(_context7, testForNoLog ? 'NOT ' : '', "log with ")).call(_context6, logLevel, " log level. ")).call(_context5, displayAllErrors ? 'But all errors are configured to display.' : ''));

      if (_indexOfInstanceProperty(LOG_LEVELS_IN_ORDER).call(LOG_LEVELS_IN_ORDER, levelToTest) <= i) {
        testForNoLog = true;
      }

      logLevelLogsCounter++;
    });
  }; // Spy console.log


  sinon.spy(console, 'log'); // Show logLevel

  runTests(true);
  runTests(true, true); // Hide logLevel

  runTests(false);
  runTests(false, true); // Restore stub.

  console.log.restore();
}

tape('SPLIT LOGGER FACTORY / Logger class public methods behaviour - instance.debug', function (assert) {
  testLogLevels(LogLevels.DEBUG, assert);
  assert.end();
});
tape('SPLIT LOGGER FACTORY / Logger class public methods behaviour - instance.info', function (assert) {
  testLogLevels(LogLevels.INFO, assert);
  assert.end();
});
tape('SPLIT LOGGER FACTORY / Logger class public methods behaviour - instance.warn', function (assert) {
  testLogLevels(LogLevels.WARN, assert);
  assert.end();
});
tape('SPLIT LOGGER FACTORY / Logger class public methods behaviour - instance.error', function (assert) {
  testLogLevels(LogLevels.ERROR, assert, true);
  assert.end();
});