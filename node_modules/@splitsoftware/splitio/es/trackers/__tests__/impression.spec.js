import _Object$defineProperty from "@babel/runtime-corejs3/core-js-stable/object/define-property";
import _Object$defineProperties from "@babel/runtime-corejs3/core-js-stable/object/define-properties";
import _Object$getOwnPropertyDescriptors from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _Object$getOwnPropertyDescriptor from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor";
import _filterInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/filter";
import _Object$getOwnPropertySymbols from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols";
import _Object$keys from "@babel/runtime-corejs3/core-js-stable/object/keys";
import _defineProperty from "@babel/runtime-corejs3/helpers/esm/defineProperty";
import _setTimeout from "@babel/runtime-corejs3/core-js-stable/set-timeout";
import _typeof from "@babel/runtime-corejs3/helpers/esm/typeof";
import _classCallCheck from "@babel/runtime-corejs3/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime-corejs3/helpers/esm/createClass";

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context; _forEachInstanceProperty(_context = ownKeys(Object(source), true)).call(_context, function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { var _context2; _forEachInstanceProperty(_context2 = ownKeys(Object(source))).call(_context2, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

import tape from 'tape-catch';
import sinon from 'sinon';
import ImpressionTracker from '../impression';
import { STORAGE, SETTINGS, INTEGRATIONS_MANAGER } from '../../utils/context/constants';
/* Mocks start */

var generateContextMocks = function generateContextMocks() {
  // We are only mocking the pieces we care about
  var fakeSettings = {
    runtime: {
      ip: 'fake-ip',
      hostname: 'fake-hostname'
    },
    version: 'js-test-10.4.0',
    impressionListener: {
      logImpression: sinon.stub()
    }
  };
  var fakeStorage = {
    impressions: {
      track: sinon.stub()
    }
  };
  var fakeIntegrationsManager = {
    handleImpression: sinon.stub()
  };
  return {
    fakeSettings: fakeSettings,
    fakeStorage: fakeStorage,
    fakeIntegrationsManager: fakeIntegrationsManager
  };
};

var ContextMock = /*#__PURE__*/function () {
  function ContextMock(fakeStorage, fakeSettings, fakeIntegrationsManager) {
    _classCallCheck(this, ContextMock);

    this.constants = {
      STORAGE: STORAGE,
      SETTINGS: SETTINGS,
      INTEGRATIONS_MANAGER: INTEGRATIONS_MANAGER
    };
    this.fakeStorage = fakeStorage;
    this.fakeSettings = fakeSettings;
    this.fakeIntegrationsManager = fakeIntegrationsManager;
  }

  _createClass(ContextMock, [{
    key: "get",
    value: function get(target) {
      switch (target) {
        case STORAGE:
          return this.fakeStorage;

        case SETTINGS:
          return this.fakeSettings;

        case INTEGRATIONS_MANAGER:
          return this.fakeIntegrationsManager;

        default:
          break;
      }
    }
  }]);

  return ContextMock;
}();
/* Mocks end */


tape('Impression Tracker', function (t) {
  t.test('Tracker API', function (assert) {
    assert.equal(_typeof(ImpressionTracker), 'function', 'The module should return a function which acts as a factory.');

    var _generateContextMocks = generateContextMocks(),
        fakeStorage = _generateContextMocks.fakeStorage,
        fakeSettings = _generateContextMocks.fakeSettings;

    var contextMock = new ContextMock(fakeStorage, fakeSettings);
    var instance = ImpressionTracker(contextMock);
    assert.equal(_typeof(instance.track), 'function', 'The instance should implement the track method.');
    assert.end();
  });
  t.test('Propagate the value as a collection into the collector', function (assert) {
    var _generateContextMocks2 = generateContextMocks(),
        fakeStorage = _generateContextMocks2.fakeStorage,
        fakeSettings = _generateContextMocks2.fakeSettings;

    var contextMock = new ContextMock(fakeStorage, fakeSettings);
    var tracker = ImpressionTracker(contextMock);
    tracker.track(10);
    assert["true"](fakeStorage.impressions.track.calledWithMatch([10]), 'Should be present in the collector sequence, which is always called with a collection.');
    assert.end();
  });
  var fakeImpression = {
    fake: 'impression'
  };
  var fakeAttributes = {
    fake: 'attributes'
  };
  t.test('Transparently propagate the impression and attributes into a listener and integration manager if provided', function (assert) {
    var _generateContextMocks3 = generateContextMocks(),
        fakeStorage = _generateContextMocks3.fakeStorage,
        fakeSettings = _generateContextMocks3.fakeSettings,
        fakeIntegrationsManager = _generateContextMocks3.fakeIntegrationsManager;

    var contextMock = new ContextMock(fakeStorage, fakeSettings, fakeIntegrationsManager);
    var tracker = ImpressionTracker(contextMock);
    tracker.track(fakeImpression, fakeAttributes);
    assert["true"](fakeStorage.impressions.track.calledWithMatch([fakeImpression]), 'Even with a listener, impression should be present in the collector sequence');
    assert["true"](!fakeSettings.impressionListener.logImpression.calledOnce, 'The listener should not be executed synchronously');
    assert["true"](!fakeIntegrationsManager.handleImpression.calledOnce, 'The integration manager handleImpression method should not be executed synchronously.');

    _setTimeout(function () {
      assert["true"](fakeSettings.impressionListener.logImpression.calledOnce, 'The listener should be executed after the timeout wrapping make it to the queue stack.');
      assert["true"](fakeIntegrationsManager.handleImpression.calledOnce, 'The integration manager handleImpression method should be executed after the timeout wrapping make it to the queue stack.');

      var impressionData = _objectSpread({
        impression: fakeImpression,
        attributes: fakeAttributes,
        sdkLanguageVersion: fakeSettings.version
      }, fakeSettings.runtime);

      assert.deepEqual(fakeSettings.impressionListener.logImpression.getCall(0).args[0], impressionData, 'The listener should be executed with the corresponding map.');
      assert.notEqual(fakeSettings.impressionListener.logImpression.getCall(0).args[0].impression, fakeImpression, 'but impression should be a copy');
      assert.deepEqual(fakeIntegrationsManager.handleImpression.getCall(0).args[0], impressionData, 'The integration manager handleImpression method should be executed with the corresponding map.');
      assert.notEqual(fakeIntegrationsManager.handleImpression.getCall(0).args[0].impression, fakeImpression, 'but impression should be a copy');
      assert.end();
    }, 0);
  });
});