import _Object$defineProperty from "@babel/runtime-corejs3/core-js-stable/object/define-property";
import _Object$defineProperties from "@babel/runtime-corejs3/core-js-stable/object/define-properties";
import _Object$getOwnPropertyDescriptors from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _Object$getOwnPropertyDescriptor from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor";
import _filterInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/filter";
import _Object$getOwnPropertySymbols from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols";
import _Object$keys from "@babel/runtime-corejs3/core-js-stable/object/keys";
import _bindInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/bind";
import _defineProperty from "@babel/runtime-corejs3/helpers/esm/defineProperty";
import _setTimeout from "@babel/runtime-corejs3/core-js-stable/set-timeout";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context6; _forEachInstanceProperty(_context6 = ownKeys(Object(source), true)).call(_context6, function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { var _context7; _forEachInstanceProperty(_context7 = ownKeys(Object(source))).call(_context7, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

import logFactory from '../utils/logger';
import thenable from '../utils/promise/thenable';
var log = logFactory('splitio-client:event-tracker');

function EventTracker(context) {
  var collector = context.get(context.constants.STORAGE).events;
  var integrationsManager = context.get(context.constants.INTEGRATIONS_MANAGER, true);

  function queueEventsCallback(eventData, tracked) {
    var _context, _context2, _context3, _context4, _context5;

    var eventTypeId = eventData.eventTypeId,
        trafficTypeName = eventData.trafficTypeName,
        key = eventData.key,
        value = eventData.value,
        timestamp = eventData.timestamp,
        properties = eventData.properties; // Logging every prop would be too much.

    var msg = _concatInstanceProperty(_context = _concatInstanceProperty(_context2 = _concatInstanceProperty(_context3 = _concatInstanceProperty(_context4 = _concatInstanceProperty(_context5 = "event of type \"".concat(eventTypeId, "\" for traffic type \"")).call(_context5, trafficTypeName, "\". Key: ")).call(_context4, key, ". Value: ")).call(_context3, value, ". Timestamp: ")).call(_context2, timestamp, ". ")).call(_context, properties ? 'With properties.' : 'With no properties.');

    if (tracked) {
      log.info("Successfully qeued ".concat(msg));

      if (integrationsManager) {
        // Wrap in a timeout because we don't want it to be blocking.
        _setTimeout(function () {
          // copy of event, to avoid unexpected behaviour if modified by integrations
          var eventDataCopy = _objectSpread({}, eventData);

          if (eventData.properties) eventDataCopy.properties = _objectSpread({}, eventData.properties); // integrationsManager does not throw errors (they are internally handled by each integration module)

          integrationsManager.handleEvent(eventDataCopy);
        }, 0);
      }
    } else {
      log.warn("Failed to queue ".concat(msg));
    }

    return tracked;
  }

  return {
    track: function track(eventData, size) {
      var tracked = collector.track(eventData, size);

      if (thenable(tracked)) {
        return tracked.then(_bindInstanceProperty(queueEventsCallback).call(queueEventsCallback, null, eventData));
      } else {
        return queueEventsCallback(eventData, tracked);
      }
    }
  };
}

export default EventTracker;