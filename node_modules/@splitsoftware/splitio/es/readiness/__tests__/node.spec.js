import _regeneratorRuntime from "@babel/runtime-corejs3/regenerator";
import _Promise from "@babel/runtime-corejs3/core-js-stable/promise";
import _asyncToGenerator from "@babel/runtime-corejs3/helpers/esm/asyncToGenerator";
import _Object$keys from "@babel/runtime-corejs3/core-js-stable/object/keys";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _typeof from "@babel/runtime-corejs3/helpers/esm/typeof";
// This is a "node" test suite because we need proxyquire as well as we have
// no differences in functionality when on the browser. When revamping the testing fwk
// analyze moving to a test that runs on both suites.
import tape from 'tape';
import sinon from 'sinon';
import proxyquire from 'proxyquire';
var proxyquireStrict = proxyquire.noCallThru();
var loggerMock = {
  warn: sinon.stub(),
  error: sinon.stub()
};

function LogFactoryMock() {
  return loggerMock;
} // Import the module mocking the logger.


var statusManager = proxyquireStrict('../statusManager', {
  '../utils/logger': LogFactoryMock
})["default"];
tape('Readiness Callbacks handler - Event emitter and returned handler', function (t) {
  var gateMock = {
    on: sinon.stub(),
    once: sinon.stub(),
    SDK_READY: 'sdk_ready_event',
    SDK_READY_FROM_CACHE: 'sdk_ready_from_cache_event',
    SDK_READY_TIMED_OUT: 'sdk_ready_timeout_event',
    SDK_UPDATE: 'sdk_update'
  };
  var contextMock = {
    put: sinon.stub(),
    get: function get(entityName) {
      return entityName === 'readiness_gate' ? {
        gate: gateMock
      } : null;
    },
    constants: {
      READINESS: 'readiness_gate',
      READY: 'is_ready'
    }
  };

  function resetStubs() {
    contextMock.put.resetHistory();
    gateMock.on.resetHistory();
    gateMock.once.resetHistory();
    loggerMock.warn.resetHistory();
    loggerMock.error.resetHistory();
  }

  t.test('Providing the gate object to get the SDK status interface that manages events', function (assert) {
    var _context;

    assert.equal(_typeof(statusManager), 'function', 'The module exposes a function.');
    var statusInterface = statusManager(contextMock);
    assert.equal(_typeof(statusInterface), 'object', 'The function receives the readiness gate and outputs a map.');

    _forEachInstanceProperty(_context = _Object$keys(gateMock)).call(_context, function (propName) {
      assert["true"](statusInterface[propName], 'The map exposes all gate functionality.');
    });

    assert.equal(_typeof(statusInterface['ready']), 'function', 'The map exposes a .ready() function.');
    assert.equal(_typeof(statusInterface.Event), 'object', 'It also exposes the Event map,');
    assert.equal(statusInterface.Event.SDK_READY, gateMock.SDK_READY, 'which contains the constants for the events, for backwards compatibility.');
    assert.equal(statusInterface.Event.SDK_READY_FROM_CACHE, gateMock.SDK_READY_FROM_CACHE, 'which contains the constants for the events, for backwards compatibility.');
    assert.equal(statusInterface.Event.SDK_READY_TIMED_OUT, gateMock.SDK_READY_TIMED_OUT, 'which contains the constants for the events, for backwards compatibility.');
    assert.equal(statusInterface.Event.SDK_UPDATE, gateMock.SDK_UPDATE, 'which contains the constants for the events, for backwards compatibility.');
    assert.equal(gateMock.once.callCount, 4, 'It should make four one time only subscriptions');
    var sdkReadyResolvePromiseCall = gateMock.once.getCall(0);
    var sdkReadyRejectPromiseCall = gateMock.once.getCall(1);
    var sdkReadyListenersCheckCall = gateMock.once.getCall(2);
    var sdkReadyFromCacheListenersCheckCall = gateMock.once.getCall(3);
    assert.equal(sdkReadyResolvePromiseCall.args[0], gateMock.SDK_READY, 'A one time only subscription is also on the SDK_READY event, for resolving the full blown ready promise.');
    assert.equal(sdkReadyRejectPromiseCall.args[0], gateMock.SDK_READY_TIMED_OUT, 'A one time only subscription is also on the SDK_READY_TIMED_OUT event, for rejecting the full blown ready promise.');
    assert.equal(sdkReadyListenersCheckCall.args[0], gateMock.SDK_READY, 'A one time only subscription is on the SDK_READY event, to check for callbacks warning.');
    assert.equal(sdkReadyFromCacheListenersCheckCall.args[0], gateMock.SDK_READY_FROM_CACHE, 'A one time only subscription is on the SDK_READY_FROM_CACHE event, to log the event and update internal state.');
    assert.ok(gateMock.on.calledTwice, 'It should also add two persistent listeners');
    var removeListenerSubCall = gateMock.on.getCall(0);
    var addListenerSubCall = gateMock.on.getCall(1);
    assert.equal(removeListenerSubCall.args[0], 'removeListener', 'First subscription should be made to the removeListener event.');
    assert.equal(addListenerSubCall.args[0], 'newListener', 'Second subscription should be made to the newListener event, after the removeListener one so we avoid an unnecessary trigger.');
    resetStubs();
    assert.end();
  });
  t.test('The event callbacks should work as expected - SDK_READY emits with no callbacks', function (assert) {
    statusManager(contextMock); // Get the callbacks

    var readyEventCB = gateMock.once.getCall(2).args[1];
    var addListenerCB = gateMock.on.getCall(1).args[1];
    readyEventCB();
    assert["true"](loggerMock.warn.calledOnce, 'If the SDK_READY event fires and we have no callbacks for it (neither event nor ready promise) we get a warning.');
    assert["true"](loggerMock.warn.calledWithExactly('No listeners for SDK Readiness detected. Incorrect control treatments could have been logged if you called getTreatment/s while the SDK was not yet ready.'), 'Telling us there were no listeners and evaluations before this point may have been incorrect.');
    assert["true"](contextMock.put.calledOnceWithExactly(contextMock.constants.READY, true), 'It also takes care of marking the SDK '); // Now it's marked as ready.

    addListenerCB('this event we do not care');
    assert["false"](loggerMock.error.called, 'Now if we add a listener to an event unrelated with readiness, we get no errors logged.');
    addListenerCB(gateMock.SDK_READY);
    assert["true"](loggerMock.error.calledOnceWithExactly('A listener was added for SDK_READY on the SDK, which has already fired and won\'t be emitted again. The callback won\'t be executed.'), 'If we try to add a listener to SDK_READY we get the corresponding warning.');
    loggerMock.error.resetHistory();
    addListenerCB(gateMock.SDK_READY_TIMED_OUT);
    assert["true"](loggerMock.error.calledOnceWithExactly('A listener was added for SDK_READY_TIMED_OUT on the SDK, which has already fired and won\'t be emitted again. The callback won\'t be executed.'), 'If we try to add a listener to SDK_READY we get the corresponding warning.');
    resetStubs();
    assert.end();
  });
  t.test('The event callbacks should work as expected - SDK_READY emits with callbacks', function (assert) {
    statusManager(contextMock); // Get the callbacks

    var readyEventCB = gateMock.once.getCall(2).args[1];
    var addListenerCB = gateMock.on.getCall(1).args[1];
    addListenerCB(gateMock.SDK_READY);
    assert["false"](loggerMock.warn.called, 'We are adding a listener to the ready event before it is ready, so no warnings are logged.');
    assert["false"](loggerMock.error.called, 'We are adding a listener to the ready event before it is ready, so no errors are logged.');
    readyEventCB();
    assert["false"](loggerMock.warn.called, 'As we had at least one listener, we get no warnings.');
    assert["false"](loggerMock.error.called, 'As we had at least one listener, we get no errors.');
    resetStubs();
    assert.end();
  });
  t.test('The event callbacks should work as expected - If we end up removing the listeners for SDK_READY, it behaves as if it had none', function (assert) {
    statusManager(contextMock); // Get the callbacks

    var readyEventCB = gateMock.once.getCall(2).args[1];
    var addListenerCB = gateMock.on.getCall(1).args[1];
    var removeListenerCB = gateMock.on.getCall(0).args[1]; // Fake adding two listeners

    addListenerCB(gateMock.SDK_READY);
    addListenerCB(gateMock.SDK_READY); // And then fake remove them.

    removeListenerCB(gateMock.SDK_READY);
    removeListenerCB(gateMock.SDK_READY);
    readyEventCB();
    assert["true"](loggerMock.warn.calledWithExactly('No listeners for SDK Readiness detected. Incorrect control treatments could have been logged if you called getTreatment/s while the SDK was not yet ready.'), 'We get the warning.');
    resetStubs();
    assert.end();
  });
  t.test('The event callbacks should work as expected - If we end up removing the listeners for SDK_READY, it behaves as if it had none', function (assert) {
    statusManager(contextMock); // Get the callbacks

    var readyEventCB = gateMock.once.getCall(2).args[1];
    var removeListenerCB = gateMock.on.getCall(0).args[1];
    var addListenerCB = gateMock.on.getCall(1).args[1]; // Fake adding two listeners

    addListenerCB(gateMock.SDK_READY);
    addListenerCB(gateMock.SDK_READY); // And then fake remove only one of them. The rest are events that we don't care about so it should not affect the count.

    removeListenerCB(gateMock.SDK_READY);
    removeListenerCB(gateMock.SDK_READY_TIMED_OUT);
    removeListenerCB('random event');
    readyEventCB();
    assert["false"](loggerMock.warn.called, 'No warning when the SDK is ready as we still have one listener.');
    resetStubs();
    assert.end();
  });
});
tape('Readiness Callbacks handler - Ready promise', function (t) {
  var gateMock = {
    on: sinon.stub(),
    once: sinon.stub(),
    SDK_READY: 'sdk_ready_event',
    SDK_READY_TIMED_OUT: 'sdk_ready_timeout_event',
    SDK_UPDATE: 'sdk_update'
  };
  var contextMock = {
    put: sinon.stub(),
    get: function get(entityName) {
      return entityName === 'readiness_gate' ? {
        gate: gateMock
      } : null;
    },
    constants: {
      READINESS: 'readiness_gate'
    }
  };

  function resetStubs() {
    contextMock.put.resetHistory();
    gateMock.on.resetHistory();
    gateMock.once.resetHistory();
    loggerMock.warn.resetHistory();
    loggerMock.error.resetHistory();
  }

  t.test('.ready() promise behaviour for shared clients', /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(assert) {
      var statusInterfaceForShared, readyForShared;
      return _regeneratorRuntime.wrap(function _callee$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              statusInterfaceForShared = statusManager(contextMock, true);
              readyForShared = statusInterfaceForShared.ready();
              assert["true"](readyForShared instanceof _Promise, 'It should return a promise.');
              _context2.next = 5;
              return readyForShared.then(function () {
                assert.pass('It should be a promise that was resolved already.');
                resetStubs();
                assert.end();
              }, function () {
                return assert.fail('It should be a promise that was resolved already, not rejected.');
              });

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }());
  t.test('.ready() promise behaviour for main clients', /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(assert) {
      var statusInterface, ready, readyEventCB, testPassed, statusInterfaceForTimedout, timedoutEventCB, readyForTimeout;
      return _regeneratorRuntime.wrap(function _callee2$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              statusInterface = statusManager(contextMock); // Default is regular clients, no bool flag

              ready = statusInterface.ready();
              assert["true"](ready instanceof _Promise, 'It should return a promise.'); // Get the callback

              readyEventCB = gateMock.once.getCall(0).args[1];
              readyEventCB(); // make the SDK "ready"

              testPassed = false;
              _context3.next = 8;
              return ready.then(function () {
                assert.pass('It should be a promise that will be resolved when the SDK is ready.');
                resetStubs();
                testPassed = true;
              }, function () {
                return assert.fail('It should be resolved on ready event, not rejected.');
              });

            case 8:
              // control assertion. stubs already reset.
              assert["true"](testPassed);
              statusInterfaceForTimedout = statusManager(contextMock); // Default is regular clients, no bool flag
              // Get the callback

              timedoutEventCB = gateMock.once.getCall(1).args[1];
              readyForTimeout = statusInterfaceForTimedout.ready();
              timedoutEventCB(); // make the SDK "timed out"

              _context3.next = 15;
              return readyForTimeout.then(function () {
                return assert.fail('It should be a promise that was rejected on SDK_READY_TIMED_OUT, not resolved.');
              }, function () {
                assert.pass('It should be a promise that will be rejected when the SDK is timed out.');
                resetStubs();
                assert.end();
              });

            case 15:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee2);
    }));

    return function (_x2) {
      return _ref2.apply(this, arguments);
    };
  }());
  t.test('Full blown ready promise count as a callback and resolves on SDK_READY', function (assert) {
    var statusInterface = statusManager(contextMock);
    var readyPromise = statusInterface.ready();
    var sdkReadyCallback = gateMock.once.getCall(2).args[1];
    var readyEventCB = gateMock.once.getCall(0).args[1];
    sdkReadyCallback(assert);
    assert["true"](loggerMock.warn.calledOnceWithExactly('No listeners for SDK Readiness detected. Incorrect control treatments could have been logged if you called getTreatment/s while the SDK was not yet ready.'), 'We would get the warning if the SDK get\'s ready before attaching any callbacks to ready promise.');
    loggerMock.warn.resetHistory();
    readyPromise.then(function () {
      assert.pass('The ready promise is resolved when the gate emits SDK_READY.');
      resetStubs();
      assert.end();
    }, function () {
      assert.fail('This should not be called as the promise is being resolved.');
      resetStubs();
      assert.end();
    });
    sdkReadyCallback();
    assert["false"](loggerMock.warn.called, 'But if we have a listener there are no warnings.'); // Resolve the promise, this would be called by the gate when SDK_READY is emitted.

    readyEventCB();
  });
});