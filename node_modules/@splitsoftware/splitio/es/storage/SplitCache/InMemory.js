import _Map from "@babel/runtime-corejs3/core-js-stable/map";
import _keysInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/keys";
import _valuesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/values";
import _toConsumableArray from "@babel/runtime-corejs3/helpers/esm/toConsumableArray";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _slicedToArray from "@babel/runtime-corejs3/helpers/esm/slicedToArray";
import _getIterator from "@babel/runtime-corejs3/core-js/get-iterator";
import _classCallCheck from "@babel/runtime-corejs3/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime-corejs3/helpers/esm/createClass";
import { isFinite } from '../../utils/lang';
import usesSegments from '../../utils/splits/usesSegments';
import killLocally from './killLocally';

var SplitCacheInMemory = /*#__PURE__*/function () {
  function SplitCacheInMemory() {
    _classCallCheck(this, SplitCacheInMemory);

    this.flush();
  }

  _createClass(SplitCacheInMemory, [{
    key: "addSplit",
    value: function addSplit(splitName, split) {
      var splitFromMemory = this.getSplit(splitName);

      if (splitFromMemory) {
        // We had this Split already
        var previousSplit = JSON.parse(splitFromMemory);

        if (previousSplit.trafficTypeName) {
          var previousTtName = previousSplit.trafficTypeName;
          this.ttCache[previousTtName]--;
          if (!this.ttCache[previousTtName]) delete this.ttCache[previousTtName];
        }

        if (usesSegments(previousSplit.conditions)) {
          // Substract from segments count for the previous version of this Split.
          this.splitsWithSegmentsCount--;
        }
      }

      var parsedSplit = JSON.parse(split);

      if (parsedSplit) {
        // Store the Split.
        this.splitCache.set(splitName, split); // Update TT cache

        var ttName = parsedSplit.trafficTypeName;

        if (ttName) {
          // safeguard
          if (!this.ttCache[ttName]) this.ttCache[ttName] = 0;
          this.ttCache[ttName]++;
        } // Add to segments count for the new version of the Split


        if (usesSegments(parsedSplit.conditions)) this.splitsWithSegmentsCount++;
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "addSplits",
    value: function addSplits(entries) {
      var results = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _getIterator(entries), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = _slicedToArray(_step.value, 2),
              key = _step$value[0],
              value = _step$value[1];

          results.push(this.addSplit(key, value));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return results;
    }
  }, {
    key: "removeSplit",
    value: function removeSplit(splitName) {
      var split = this.getSplit(splitName);

      if (split) {
        // Delete the Split
        this.splitCache["delete"](splitName);
        var parsedSplit = JSON.parse(split);
        var ttName = parsedSplit.trafficTypeName;

        if (ttName) {
          // safeguard
          this.ttCache[ttName]--; // Update tt cache

          if (!this.ttCache[ttName]) delete this.ttCache[ttName];
        } // Update the segments count.


        if (usesSegments(parsedSplit.conditions)) this.splitsWithSegmentsCount--;
        return 1;
      } else {
        return 0;
      }
    }
  }, {
    key: "removeSplits",
    value: function removeSplits(splitNames) {
      var _this = this;

      _forEachInstanceProperty(splitNames).call(splitNames, function (n) {
        return _this.removeSplit(n);
      });

      return splitNames.length;
    }
  }, {
    key: "getSplit",
    value: function getSplit(splitName) {
      return this.splitCache.get(splitName);
    }
  }, {
    key: "setChangeNumber",
    value: function setChangeNumber(changeNumber) {
      this.changeNumber = changeNumber;
      return true;
    }
  }, {
    key: "getChangeNumber",
    value: function getChangeNumber() {
      return this.changeNumber;
    }
  }, {
    key: "getAll",
    value: function getAll() {
      var _context;

      return _toConsumableArray(_valuesInstanceProperty(_context = this.splitCache).call(_context));
    }
  }, {
    key: "getKeys",
    value: function getKeys() {
      var _context2;

      return _toConsumableArray(_keysInstanceProperty(_context2 = this.splitCache).call(_context2));
    }
  }, {
    key: "trafficTypeExists",
    value: function trafficTypeExists(trafficType) {
      return isFinite(this.ttCache[trafficType]) && this.ttCache[trafficType] > 0;
    }
  }, {
    key: "usesSegments",
    value: function usesSegments() {
      return this.getChangeNumber() === -1 || this.splitsWithSegmentsCount > 0;
    }
  }, {
    key: "flush",
    value: function flush() {
      this.splitCache = new _Map();
      this.ttCache = {};
      this.changeNumber = -1;
      this.splitsWithSegmentsCount = 0;
    }
    /**
     * Fetches multiple splits definitions.
     */

  }, {
    key: "fetchMany",
    value: function fetchMany(splitNames) {
      var _this2 = this;

      var splits = new _Map();

      _forEachInstanceProperty(splitNames).call(splitNames, function (splitName) {
        splits.set(splitName, _this2.splitCache.get(splitName) || null);
      });

      return splits;
    }
    /**
     * Check if the splits information is already stored in cache. In memory there is no cache to check.
     */

  }, {
    key: "checkCache",
    value: function checkCache() {
      return false;
    }
  }]);

  return SplitCacheInMemory;
}();

SplitCacheInMemory.prototype.killLocally = killLocally;
export default SplitCacheInMemory;